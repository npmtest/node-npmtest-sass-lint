{"/home/travis/build/npmtest/node-npmtest-sass-lint/test.js":"/* istanbul instrument in package npmtest_sass_lint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sass-lint/lib.npmtest_sass_lint.js":"/* istanbul instrument in package npmtest_sass_lint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sass_lint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sass_lint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sass-lint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sass-lint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sass_lint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sass_lint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sass_lint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_sass_lint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sass_lint.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_sass_lint.__dirname +\n                    '/lib.npmtest_sass_lint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/index.js":"'use strict';\n\nvar slConfig = require('./lib/config'),\n    groot = require('./lib/groot'),\n    exceptions = require('./lib/exceptions'),\n    helpers = require('./lib/helpers'),\n    slRules = require('./lib/rules'),\n    ruleToggler = require('./lib/ruleToggler'),\n    glob = require('glob'),\n    path = require('path'),\n    fs = require('fs-extra'),\n    globule = require('globule');\n\nvar getToggledRules = ruleToggler.getToggledRules,\n    isResultEnabled = ruleToggler.isResultEnabled;\n\nvar sassLint = function (config) { // eslint-disable-line no-unused-vars\n  config = require('./lib/config')(config);\n  return;\n};\n\n/**\n * Takes any user specified options and a configPath\n * which returns a compiled config object\n *\n * @param {object} config user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} the compiled config object\n */\nsassLint.getConfig = function (config, configPath) {\n  return slConfig(config, configPath);\n};\n\n/**\n * Parses our results object to count errors and return\n * paths to files with detected errors.\n *\n * @param {object} results our results object\n * @returns {object} errors object containing the error count and paths for files incl. errors\n */\nsassLint.errorCount = function (results) {\n  var errors = {\n    count: 0,\n    files: []\n  };\n\n  results.forEach(function (result) {\n    if (result.errorCount) {\n      errors.count += result.errorCount;\n      errors.files.push(result.filePath);\n    }\n  });\n\n  return errors;\n};\n\n/**\n * Parses our results object to count warnings and return\n * paths to files with detected warnings.\n *\n * @param {object} results our results object\n * @returns {object} warnings object containing the error count and paths for files incl. warnings\n */\nsassLint.warningCount = function (results) {\n  var warnings = {\n    count: 0,\n    files: []\n  };\n\n  results.forEach(function (result) {\n    if (result.warningCount) {\n      warnings.count += result.warningCount;\n      warnings.files.push(result.filePath);\n    }\n  });\n\n  return warnings;\n};\n\n/**\n * Parses our results object to count warnings and errors and return\n * a cumulative count of both\n *\n * @param {object} results our results object\n * @returns {int} the cumulative count of errors and warnings detected\n */\nsassLint.resultCount = function (results) {\n  var warnings = this.warningCount(results),\n      errors = this.errorCount(results);\n\n  return warnings.count + errors.count;\n};\n\n/**\n * Runs each rule against our AST tree and returns our main object of detected\n * errors, warnings, messages and filenames.\n *\n * @param {object} file file object from fs.readFileSync\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} an object containing error & warning counts plus lint messages for each parsed file\n */\nsassLint.lintText = function (file, options, configPath) {\n  var rules = slRules(this.getConfig(options, configPath)),\n      ast = {},\n      detects,\n      results = [],\n      errors = 0,\n      warnings = 0,\n      ruleToggles = null,\n      isEnabledFilter = null;\n\n  try {\n    ast = groot(file.text, file.format, file.filename);\n  }\n  catch (e) {\n    var line = e.line || 1;\n    errors++;\n\n    results = [{\n      ruleId: 'Fatal',\n      line: line,\n      column: 1,\n      message: e.message,\n      severity: 2\n    }];\n  }\n\n  if (ast.content && ast.content.length > 0) {\n    ruleToggles = getToggledRules(ast);\n    isEnabledFilter = isResultEnabled(ruleToggles);\n\n    rules.forEach(function (rule) {\n      detects = rule.rule.detect(ast, rule)\n        .filter(isEnabledFilter);\n      results = results.concat(detects);\n      if (detects.length) {\n        if (rule.severity === 1) {\n          warnings += detects.length;\n        }\n        else if (rule.severity === 2) {\n          errors += detects.length;\n        }\n      }\n    });\n  }\n\n  results.sort(helpers.sortDetects);\n\n  return {\n    'filePath': file.filename,\n    'warningCount': warnings,\n    'errorCount': errors,\n    'messages': results\n  };\n};\n\n/**\n * Handles ignored files for plugins such as the gulp plugin. Checks every file passed to it against\n * the ignores as specified in our users config or passed in options.\n *\n * @param {object} file - The file/text to be linted\n * @param {object} options - The user defined options directly passed in\n * @param {object} configPath - Path to a config file\n * @returns {object} Return the results of lintText - a results object\n */\nsassLint.lintFileText = function (file, options, configPath) {\n  var config = this.getConfig(options, configPath),\n      ignores = config.files ? config.files.ignore : [];\n\n  if (!globule.isMatch(ignores, file.filename)) {\n    return this.lintText(file, options, configPath);\n  }\n\n  return {\n    'filePath': file.filename,\n    'warningCount': 0,\n    'errorCount': 0,\n    'messages': []\n  };\n};\n\n/**\n * Takes a glob pattern or target string and creates an array of files as targets for\n * linting taking into account any user specified ignores. For each resulting file sassLint.lintText\n * is called which returns an object of results for that file which we push to our results object.\n *\n * @param {string} files a glob pattern or single file path as a lint target\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} results object containing all results\n */\nsassLint.lintFiles = function (files, options, configPath) {\n  var that = this,\n      results = [],\n      includes = [],\n      ignores = '';\n\n  // Files passed as a string on the command line\n  if (files) {\n    ignores = this.getConfig(options, configPath).files.ignore || '';\n    if (files.indexOf(', ') !== -1) {\n      files.split(', ').forEach(function (pattern) {\n        includes = includes.concat(glob.sync(pattern, {ignore: ignores, nodir: true}));\n      });\n    }\n    else {\n      includes = glob.sync(files, {ignore: ignores, nodir: true});\n    }\n  }\n  // If not passed in then we look in the config file\n  else {\n    files = this.getConfig(options, configPath).files;\n    // A glob pattern of files can be just a string\n    if (typeof files === 'string') {\n      includes = glob.sync(files, {nodir: true});\n    }\n    // Look into the include property of files and check if there's an array of files\n    else if (files.include && files.include instanceof Array) {\n      files.include.forEach(function (pattern) {\n        includes = includes.concat(glob.sync(pattern, {ignore: files.ignore, nodir: true}));\n      });\n    }\n    // Or there is only one pattern in the include property of files\n    else {\n      includes = glob.sync(files.include, {ignore: files.ignore, nodir: true});\n    }\n  }\n\n  includes.forEach(function (file, index) {\n    // Only lint non duplicate files from our glob results\n    if (includes.indexOf(file) === index) {\n      var lint = that.lintText({\n        'text': fs.readFileSync(file),\n        'format': options.syntax ? options.syntax : path.extname(file).replace('.', ''),\n        'filename': file\n      }, options, configPath);\n      results.push(lint);\n    }\n  });\n\n  return results;\n};\n\n/**\n * Handles formatting of results using EsLint formatters\n *\n * @param {object} results our results object\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} results our results object in the user specified format\n */\nsassLint.format = function (results, options, configPath) {\n  var config = this.getConfig(options, configPath),\n      format = config.options.formatter.toLowerCase();\n\n  var formatted = require('eslint/lib/formatters/' + format);\n\n  return formatted(results);\n};\n\n/**\n * Handles outputting results whether this be straight to the console/stdout or to a file.\n * Passes results to the format function to ensure results are output in the chosen format\n *\n * @param {object} results our results object\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} results our results object\n */\nsassLint.outputResults = function (results, options, configPath) {\n  var config = this.getConfig(options, configPath);\n\n  if (this.resultCount(results)) {\n\n    var formatted = this.format(results, options, configPath);\n\n    if (config.options['output-file']) {\n      try {\n        fs.outputFileSync(path.resolve(process.cwd(), config.options['output-file']), formatted);\n        console.log('Output successfully written to ' + path.resolve(process.cwd(), config.options['output-file']));\n      }\n      catch (e) {\n        console.log('Error: Output was unable to be written to ' + path.resolve(process.cwd(), config.options['output-file']));\n      }\n    }\n    else {\n      console.log(formatted);\n    }\n  }\n  return results;\n};\n\n/**\n * Throws an error if there are any errors detected. The error includes a count of all errors\n * and a list of all files that include errors.\n *\n * @param {object} results - our results object\n * @param {object} [options] - extra options to use when running failOnError, e.g. max-warnings\n * @param {string} [configPath] - path to the config file\n * @returns {void}\n */\nsassLint.failOnError = function (results, options, configPath) {\n  // Default parameters\n  options = typeof options !== 'undefined' ? options : {};\n  configPath = typeof configPath !== 'undefined' ? configPath : null;\n\n  var errorCount = this.errorCount(results),\n      warningCount = this.warningCount(results),\n      configOptions = this.getConfig(options, configPath).options;\n\n  if (errorCount.count > 0) {\n    throw new exceptions.SassLintFailureError(errorCount.count + ' errors were detected in \\n- ' + errorCount.files.join('\\n- '));\n  }\n\n  if (!isNaN(configOptions['max-warnings']) && warningCount.count > configOptions['max-warnings']) {\n    throw new exceptions.MaxWarningsExceededError(\n      'Number of warnings (' + warningCount.count +\n      ') exceeds the allowed maximum of ' + configOptions['max-warnings'] +\n      '.\\n'\n    );\n  }\n};\n\nmodule.exports = sassLint;\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/config.js":"'use strict';\n\nvar path = require('path'),\n    merge = require('merge'),\n    confHelpers = require('./config-helpers'),\n    pathIsAbsolute = require('path-is-absolute');\n\nvar cacheConfig = {},\n    cacheEnabled = false;\n\nmodule.exports = function (options, configPath) {\n  var meta = null,\n      metaPath,\n      configMerge = false,\n      configMergeExists = false,\n      optionsMerge = false,\n      optionsMergeExists = false,\n      finalCacheExists = false,\n      config = {},\n      finalConfig = {},\n      defaults;\n\n  // ensure our inline options and rules are not undefined\n  options = options ? options : {};\n  options.rules = options.rules ? options.rules : {};\n\n  // ensure our user defined cache option is respected\n  if (options.options && options.options.hasOwnProperty('cache-config')) {\n    if (options.options['cache-config'] && Object.keys(cacheConfig).length) {\n      return cacheConfig;\n    }\n  }\n  else {\n    // check to see if the config cache already exists and is enabled\n    if (cacheEnabled && Object.keys(cacheConfig).length) {\n      return cacheConfig;\n    }\n  }\n\n  if (options.options && options.options['config-file']) {\n    configPath = options.options['config-file'];\n  }\n\n  if (!configPath) {\n    metaPath = confHelpers.findFile(false, 'package.json');\n    if (metaPath) {\n      meta = require(metaPath);\n    }\n\n    if (meta && meta.sasslintConfig) {\n      configPath = path.resolve(path.dirname(metaPath), meta.sasslintConfig);\n    }\n    else {\n      configPath = confHelpers.findFile(false, '.sass-lint.yml');\n    }\n  }\n  else if (!pathIsAbsolute(configPath)) {\n    configPath = path.resolve(process.cwd(), configPath);\n  }\n\n  config = confHelpers.loadConfig(configPath);\n  config = confHelpers.checkForConfigExtend(config, configPath);\n\n  // check to see if user config contains an options property and whether property has a property called merge-default-rules\n  configMergeExists = (config.options && typeof config.options['merge-default-rules'] !== 'undefined');\n\n  // If it does then retrieve the value of it here or return false\n  configMerge = configMergeExists ? config.options['merge-default-rules'] : false;\n\n  // check to see if inline options contains an options property and whether property has a property called merge-default-rules\n  optionsMergeExists = (options.options && typeof options.options['merge-default-rules'] !== 'undefined');\n\n  // If it does then retrieve the value of it here or return false\n  optionsMerge = optionsMergeExists ? options.options['merge-default-rules'] : false;\n\n\n  // order of preference is inline options > user config > default config\n  // merge-default-rules defaults to true so each step above should merge with the previous. If at any step merge-default-rules is set to\n  // false it should skip that steps merge.\n  defaults = confHelpers.loadDefaults();\n  finalConfig = merge.recursive(defaults, config, options);\n\n  // if merge-default-rules is set to false in user config file then we essentially skip the merging with default rules by overwriting our\n  // final rules with the content of our user config otherwise we don't take action here as the default merging has already happened\n  if (configMergeExists && !configMerge) {\n    finalConfig.rules = config.rules;\n  }\n\n  // if merge-default-rules is set to false in inline options we essentially skip the merging with our current rules by overwriting our\n  // final rules with the content of our user config otherwise we check to see if merge-default-rules is true OR that we have any inline\n  // rules, if we do then we want to merge these into our final ruleset.\n  if (optionsMergeExists && !optionsMerge) {\n    finalConfig.rules = options.rules;\n  }\n  else if ((optionsMergeExists && optionsMerge) || options.rules && Object.keys(options.rules).length > 0) {\n    finalConfig.rules = merge.recursive(finalConfig.rules, options.rules);\n  }\n\n  // check to see if our final config contains a cache-config value\n  finalCacheExists = (finalConfig.options && typeof finalConfig.options['cache-config'] !== 'undefined');\n\n  // set our global cache enabled flag here, it will be false by default\n  cacheEnabled = finalCacheExists ? finalConfig.options['cache-config'] : false;\n\n  // set our cached config to our final config\n  cacheConfig = cacheEnabled ? finalConfig : {};\n\n  return finalConfig;\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/config-helpers.js":"var yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path'),\n    merge = require('merge'),\n    pathIsAbsolute = require('path-is-absolute');\n\n/**\n * Loads the default sass-lint configuration file\n *\n * @returns {Object} The default sass-lint configuration\n */\nvar loadDefaults = function loadDefaults () {\n  return yaml.safeLoad(fs.readFileSync(path.join(__dirname, 'config', 'sass-lint.yml'), 'utf8'));\n};\n\n/**\n * Attempts to traverse the tree looking for the specified file\n *\n * @param {String} configPath - The path to look for the file.\n * @param {String} filename - The name of the file.\n * @returns {String} The resolved path\n */\nvar findFile = function findFile (configPath, filename) {\n  var HOME = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE,\n      dirname = null,\n      parentDirname = null;\n\n  configPath = configPath || path.join(process.cwd(), filename);\n\n  if (configPath && fs.existsSync(configPath)) {\n    return fs.realpathSync(configPath);\n  }\n  dirname = path.dirname(configPath);\n  parentDirname = path.dirname(dirname);\n\n  if (dirname === null || dirname === HOME || dirname === parentDirname) {\n    return null;\n  }\n  configPath = path.join(parentDirname, filename);\n\n  return findFile(configPath, filename);\n};\n\n/**\n * Loads a config file from a specified path if it exists. The resolved config will be returned\n * or a blank config will be in it's place.\n *\n * @param {String} cPath - The path to the config file\n * @returns {Object} The configuration object\n */\nvar loadConfig = function (cPath) {\n  var configPath = cPath,\n      resolvedConfig = {};\n\n  if (configPath) {\n    if (fs.existsSync(configPath)) {\n      resolvedConfig = yaml.safeLoad(fs.readFileSync(configPath, 'utf8')) || {};\n    }\n  }\n\n  return {\n    options: resolvedConfig.options || {},\n    files: resolvedConfig.files || {},\n    rules: resolvedConfig.rules || {}\n  };\n};\n\n/**\n * Checks a config file to see if another config file is specified, if it is, the file is laoded\n * and merged with the current configuration object.\n *\n * @param {Object} config - The current configuration\n * @param {String} curConfPath - The current path(incl filename) to the configuration object passed as 'config'\n * @returns {Object} The merged configuration object\n */\nvar checkForConfigExtend = function (config, curConfPath) {\n  var mergedConfig = config,\n      subConfig = config.options['config-file'] || false,\n      confPath,\n      resolvedSubConfig;\n\n  if (subConfig) {\n    if (!pathIsAbsolute(subConfig)) {\n      // Process.cwd() in most IDE's will be / so therefore we need to pass the current directory\n      // of the config from which you are 'extending' or we resort to process.cwd() which on the CLI\n      // will be correct\n      confPath = curConfPath ? path.dirname(curConfPath) : process.cwd();\n      subConfig = path.resolve(confPath, subConfig);\n    }\n    // Attempt to load the new found config file\n    resolvedSubConfig = loadConfig(subConfig, curConfPath);\n    // Check the new config file to see if it too is extending\n    resolvedSubConfig = checkForConfigExtend(resolvedSubConfig, subConfig);\n    // Merge our configs with the first encountered being the most important, down to the last config\n    // being the least.\n    mergedConfig = merge.recursive(resolvedSubConfig, config);\n  }\n\n  return mergedConfig;\n};\n\nmodule.exports = {\n  loadDefaults: loadDefaults,\n  findFile: findFile,\n  loadConfig: loadConfig,\n  checkForConfigExtend: checkForConfigExtend\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/groot.js":"//////////////////////////////\n// Tree Abstraction\n//////////////////////////////\n'use strict';\n\nvar gonzales = require('gonzales-pe');\nvar fm = require('front-matter');\nvar helpers = require('./helpers');\n\nmodule.exports = function (text, syntax, filename) {\n  var tree;\n\n  // Run `.toString()` to allow Buffers to be passed in\n  text = helpers.stripBom(text.toString());\n\n  // if we're skipping front matter do it here, fall back to just our text in case it fails\n  if (fm.test(text)) {\n    text = fm(text).body || text;\n  }\n\n  try {\n    tree = gonzales.parse(text, {\n      'syntax': syntax\n    });\n  }\n  catch (e) {\n    throw {\n      message: e.message,\n      file: filename,\n      line: e.line\n    };\n  }\n\n  if (typeof tree === 'undefined') {\n    throw {\n      message: 'Undefined tree',\n      file: filename,\n      text: text.toString(),\n      tree: tree.toString()\n    };\n  }\n\n  return tree;\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/helpers.js":"'use strict';\n\nvar util = require('util'),\n    fs = require('fs'),\n    path = require('path'),\n    yaml = require('js-yaml'),\n    gonzales = require('gonzales-pe');\n\nvar helpers = {};\n\nhelpers.log = function log (input) {\n  console.log(util.inspect(input, false, null));\n};\n\nhelpers.propertySearch = function (haystack, needle, property) {\n  var length = haystack.length,\n      i;\n\n  for (i = 0; i < length; i++) {\n    if (haystack[i][property] === needle) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nhelpers.isEqual = function (a, b) {\n  var startLine = a.start.line === b.start.line ? true : false,\n      endLine = a.end.line === b.end.line ? true : false,\n      type = a.type === b.type ? true : false,\n      length = a.content.length === b.content.length ? true : false;\n\n  if (startLine && endLine && type && length) {\n    return true;\n  }\n  else {\n    return false;\n  }\n};\n\nhelpers.isUnique = function (results, item) {\n  var search = this.propertySearch(results, item.line, 'line');\n\n  if (search === -1) {\n    return true;\n  }\n  else if (results[search].column === item.column && results[search].message === item.message) {\n    return false;\n  }\n  else {\n    return true;\n  }\n};\n\nhelpers.addUnique = function (results, item) {\n  if (this.isUnique(results, item)) {\n    results.push(item);\n  }\n  return results;\n};\n\nhelpers.sortDetects = function (a, b) {\n  if (a.line < b.line) {\n    return -1;\n  }\n  if (a.line > b.line) {\n    return 1;\n  }\n  if (a.line === b.line) {\n    if (a.column < b.column) {\n      return -1;\n    }\n    if (a.column > b.column) {\n      return 1;\n    }\n    return 0;\n  }\n  return 0;\n};\n\nhelpers.isNumber = function (val) {\n  if (isNaN(parseInt(val, 10))) {\n    return false;\n  }\n  return true;\n};\n\nhelpers.isUpperCase = function (str) {\n  var pieces = str.split(''),\n      i,\n      result = 0;\n\n  for (i = 0; i < pieces.length; i++) {\n    if (!helpers.isNumber(pieces[i])) {\n      if (pieces[i] === pieces[i].toUpperCase() && pieces[i] !== pieces[i].toLowerCase()) {\n        result++;\n      }\n      else {\n        return false;\n      }\n    }\n  }\n  if (result) {\n    return true;\n  }\n  return false;\n};\n\nhelpers.isLowerCase = function (str) {\n  var pieces = str.split(''),\n      i,\n      result = 0;\n\n  for (i = 0; i < pieces.length; i++) {\n    if (!helpers.isNumber(pieces[i])) {\n      if (pieces[i] === pieces[i].toLowerCase() && pieces[i] !== pieces[i].toUpperCase()) {\n        result++;\n      }\n      else {\n        return false;\n      }\n    }\n  }\n  if (result) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Determines if a given string adheres to camel-case format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to camel-case format\n */\nhelpers.isCamelCase = function (str) {\n  return /^[a-z][a-zA-Z0-9]*$/.test(str);\n};\n\n/**\n * Determines if a given string adheres to pascal-case format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to pascal-case format\n */\nhelpers.isPascalCase = function (str) {\n  return /^[A-Z][a-zA-Z0-9]*$/.test(str);\n};\n\n/**\n * Determines if a given string adheres to hyphenated-lowercase format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to hyphenated-lowercase format\n */\nhelpers.isHyphenatedLowercase = function (str) {\n  return !(/[^\\-a-z0-9]/.test(str));\n};\n\n/**\n * Determines if a given string adheres to snake-case format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to snake-case format\n */\nhelpers.isSnakeCase = function (str) {\n  return !(/[^_a-z0-9]/.test(str));\n};\n\n/**\n * Determines if a given string adheres to strict-BEM format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to strict-BEM format\n */\nhelpers.isStrictBEM = function (str) {\n  return /^[a-z](\\-?[a-z0-9]+)*(__[a-z0-9](\\-?[a-z0-9]+)*)?((_[a-z0-9](\\-?[a-z0-9]+)*){0,2})?$/.test(str);\n};\n\n/**\n * Determines if a given string adheres to hyphenated-BEM format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to hyphenated-BEM format\n */\nhelpers.isHyphenatedBEM = function (str) {\n  return !(/[A-Z]|-{3}|_{3}|[^_]_[^_]/.test(str));\n};\n\nhelpers.isValidHex = function (str) {\n  if (str.match(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a node is a newline character or not\n *\n * @param {Object} node - The node to test\n * @returns {boolean} Whether the node is a newline or not\n */\nhelpers.isNewLine = function (node) {\n  // using type === instead of is just in case node happens to be a string\n  return !!(node && node.type === 'space' && node.content.match('\\n'));\n};\n\n/**\n * Check if a node is a non newline space character or not\n *\n * @param {Object} node - The node to test\n * @returns {boolean} Whether the node is a non newline space or not\n */\nhelpers.isSpace = function (node) {\n  return !!(node && node.type === 'space' && !node.content.match('\\n'));\n};\n\nhelpers.loadConfigFile = function (configPath) {\n  var fileDir = path.dirname(configPath),\n      fileName = path.basename(configPath),\n      fileExtension = path.extname(fileName),\n      filePath = path.join(__dirname, 'config', fileDir, fileName),\n      file = fs.readFileSync(filePath, 'utf8') || false;\n\n  if (file) {\n    if (fileExtension === '.yml') {\n      return yaml.safeLoad(file);\n    }\n  }\n\n  return file;\n};\n\nhelpers.hasEOL = function (str) {\n  return /\\r\\n|\\n/.test(str);\n};\n\nhelpers.isEmptyLine = function (str) {\n  return /(\\r\\n|\\n){2}/.test(str);\n};\n\nhelpers.stripQuotes = function (str) {\n  return str.substring(1, str.length - 1);\n};\n\n/**\n * Strips vendor prefixes from a string\n *\n * @param {string} str - The string we wish to remove vendor prefixes from\n * @returns {string} The string without vendor prefixes\n */\nhelpers.stripPrefix = function (str) {\n  var modPropertyArr = str.split('-'),\n      modProperty = '',\n      prefLength = modPropertyArr[2] === 'osx' ? 2 : 1;\n\n  modPropertyArr.splice(1, prefLength);\n\n  modPropertyArr.forEach(function (item, index) {\n    modProperty = modProperty + item;\n    if (index > 0 && index < modPropertyArr.length - 1) {\n      modProperty = modProperty + '-';\n    }\n  });\n\n  return modProperty;\n};\n\n/**\n * Removes the trailing space from a string\n * @param {string} curSelector - the current selector string\n * @returns {string} curSelector - the current selector minus any trailing space.\n */\n\nhelpers.stripLastSpace = function (selector) {\n\n  if (selector.charAt(selector.length - 1) === ' ') {\n    return selector.substr(0, selector.length - 1);\n\n  }\n\n  return selector;\n\n};\n\n/**\n * Checks the current selector value against the previous selector value and assesses whether they are\n * a) currently an enforced selector type for nesting (user specified - all true by default)\n * b) whether they should be nested\n * @param {object} currentVal - the current node / part of our selector\n * @param {object} previousVal - the previous node / part of our selector\n * @param {array} elements - a complete array of nestable selector types\n * @param {array} nestable - an array of the types of selector to nest\n * @returns {object} Returns whether we or we should nest and the previous val\n */\nhelpers.isNestable = function (currentVal, previousVal, elements, nestable) {\n  // check if they are nestable by checking the previous element against one\n  // of the user specified selector types\n  if (elements.indexOf(previousVal) !== -1 && nestable.indexOf(currentVal) !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Tries to traverse the AST, following a specified path\n * @param   {object}  node           Starting node\n * @param   {array}   traversalPath  Array of Node types to traverse, starting from the first element\n * @returns {array}                  Nodes at the end of the path. Empty array if the traversal failed\n */\nhelpers.attemptTraversal = function (node, traversalPath) {\n  var i,\n      nextNodeList,\n      currentNodeList = [],\n      processChildNode = function processChildNode (child) {\n        child.forEach(traversalPath[i], function (n) {\n          nextNodeList.push(n);\n        });\n      };\n\n  node.forEach(traversalPath[0], function (n) {\n    currentNodeList.push(n);\n  });\n\n  for (i = 1; i < traversalPath.length; i++) {\n    if (currentNodeList.length === 0) {\n      return [];\n    }\n\n    nextNodeList = [];\n    currentNodeList.forEach(processChildNode);\n    currentNodeList = nextNodeList;\n  }\n  return currentNodeList;\n};\n\n/**\n * Collects all suffix extensions for a selector\n * @param   {object}  ruleset      ASTNode of type ruleset, containing a selector with nested suffix extensions\n * @param   {string}  selectorType Node type of the selector (e.g. class, id)\n * @returns {array}                Array of Nodes with the content property replaced by the complete selector\n *                                       (without '.', '#', etc) resulting from suffix extensions\n */\nhelpers.collectSuffixExtensions = function (ruleset, selectorType) {\n  var parentSelectors = helpers.attemptTraversal(ruleset, ['selector', selectorType, 'ident']),\n      childSuffixes = helpers.attemptTraversal(ruleset, ['block', 'ruleset']),\n      selectorList = [];\n\n  if (parentSelectors.length === 0) {\n    return [];\n  }\n\n  // Goes recursively through all nodes that look like suffix extensions. There may be multiple parents that are\n  // extended, so lots of looping is required.\n  var processChildSuffix = function (child, parents) {\n    var currentParents = [],\n        selectors = helpers.attemptTraversal(child, ['selector', 'parentSelectorExtension', 'ident']),\n        nestedChildSuffixes = helpers.attemptTraversal(child, ['block', 'ruleset']);\n\n    selectors.forEach(function (childSuffixNode) {\n      // append suffix extension to all parent selectors\n      parents.forEach(function (parent) {\n        // clone so we don't modify the actual AST\n        var clonedChildSuffixNode = gonzales.createNode(childSuffixNode);\n        clonedChildSuffixNode.content = parent.content + clonedChildSuffixNode.content;\n\n        currentParents.push(clonedChildSuffixNode);\n      });\n    });\n\n    selectorList = selectorList.concat(currentParents);\n\n    nestedChildSuffixes.forEach(function (childSuffix) {\n      processChildSuffix(childSuffix, currentParents);\n    });\n  };\n\n  childSuffixes.forEach(function (childSuffix) {\n    processChildSuffix(childSuffix, parentSelectors);\n  });\n\n  return parentSelectors.concat(selectorList);\n};\n\n/**\n * Check for the partial match of a string in an array\n *\n * @param {string} needle - The value to match\n * @param {Array} haystack - The array of values to try and match to\n * @returns {Boolean} Whether there is a partial match or not\n */\nhelpers.isPartialStringMatch = function (needle, haystack) {\n  for (var i = 0; i < haystack.length; i++) {\n    if (haystack[i].indexOf(needle) >= 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n *  A copy of the the stripBom module from https://github.com/sindresorhus/strip-bom/blob/master/index.js\n *  The module requires node > 4 whereas we support earlier versions.\n *  This function strips the BOM marker from the beginning of a file\n *\n * @param {string} str - The string we wish to strip the BOM marker from\n * @returns {string} The string without a BOM marker\n */\nhelpers.stripBom = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string, got ' + typeof str);\n  }\n\n  if (str.charCodeAt(0) === 0xFEFF) {\n    return str.slice(1);\n  }\n\n  return str;\n};\n\nmodule.exports = helpers;\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/exceptions.js":"'use strict';\n\nvar util = require('util');\n\nmodule.exports = {\n  SassLintFailureError: function (message) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = 'SassLintFailureError';\n    this.message = message;\n  },\n  MaxWarningsExceededError: function (message) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = 'MaxWarningsExceededError';\n    this.message = message;\n  }\n};\n\nutil.inherits(module.exports.SassLintFailureError, Error);\nutil.inherits(module.exports.MaxWarningsExceededError, Error);\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules.js":"'use strict';\n\nvar merge = require('merge'),\n    path = require('path'),\n    fs = require('fs');\n\nvar searchArray = function (haystack, needle) {\n  var i;\n  for (i = 0; i < haystack.length; i++) {\n    if (haystack[i].indexOf(needle) >= 0) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nmodule.exports = function (config) {\n  var handlers = [],\n      i,\n      rules;\n\n  rules = fs.readdirSync(path.join(__dirname, 'rules'));\n  for (i = 0; i < rules.length; i++) {\n    rules[i] = path.join(__dirname, 'rules', rules[i]);\n  }\n\n  Object.keys(config.rules).forEach(function (rule) {\n    var fullRule = config.rules[rule],\n        loadRule,\n        severity,\n        options,\n        ruleSearch;\n\n    if (typeof fullRule === 'number') {\n      severity = fullRule;\n      options = {};\n    }\n    else {\n      severity = fullRule[0];\n      options = fullRule[1];\n    }\n\n    // Only seek out rules that are enabled\n    if (severity !== 0) {\n      var fileName = path.normalize(path.join('/', rule + '.js'));\n\n      ruleSearch = searchArray(rules, fileName);\n\n      if (ruleSearch >= 0) {\n        loadRule = require(rules[ruleSearch]);\n\n        options = merge.recursive(true, loadRule.defaults, options);\n\n        handlers.push({\n          'rule': loadRule,\n          'severity': severity,\n          'options': options\n        });\n      }\n      else {\n        throw new Error('Rule `' + rule + '` could not be found!');\n      }\n    }\n  });\n\n  return handlers;\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/ruleToggler.js":"'use strict';\n\n/**\n * Adds each rule in our array of rules in a disable comment into the toggledRules object\n * under the correct rule name along with the line and column number where the disable comment\n * was encountered\n *\n * @param {Object} toggledRules - Contains the information about each rule disable/enable\n                                  encountered and and what line/column it occurred on\n * @param {Array} rules - An array of rule names\n * @param {number} line - The line number the disable appeared on\n * @param {number} column - The column number the disable appeared on\n */\nvar addDisable = function (toggledRules, rules, line, column) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    toggledRules.ruleEnable[rule].push([false, line, column]);\n  });\n};\n\n/**\n * Adds each rule in our array of rules in a enable comment into the toggledRules object\n * under the correct rule name along with the line and column number where the enable comment\n * was encountered\n *\n * @param {Object} toggledRules - Contains the information about each rule enable\n                                  encountered and and what line/column it occurred on\n * @param {Array} rules - An array of rule names\n * @param {number} line - The line number the enable appeared on\n * @param {number} column - The column number the enable appeared on\n */\nvar addEnable = function (toggledRules, rules, line, column) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    toggledRules.ruleEnable[rule].push([true, line, column]);\n  });\n};\n\n/**\n * Adds each rule in our array of rules in a disable block comment into the toggledRules object\n * under the correct rule name along with the line and column number where the disable block comment\n * was encountered\n *\n * @param {Object} toggledRules - Contains the information about each rule enable\n                                  encountered and and what line/column that block occurred on\n * @param {Array} rules - An array of rule names\n * @param {Object} block - The block that is to be disabled\n */\nvar addDisableBlock = function (toggledRules, rules, block) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    toggledRules.ruleEnable[rule].push([false, block.start.line, block.start.column]);\n    toggledRules.ruleEnable[rule].push([true, block.end.line, block.end.column]);\n  });\n};\n\n/**\n * Adds a globally disabled flag to the toggled rules globalEnable property including the line and column\n * that this comment was encountered on.\n *\n * @param {Object} toggledRules - Contains the information about the global disable comment\n                                  encountered and and what line/column it occurred on\n * @param {number} line - The line number the disable appeared on\n * @param {number} column - The column number the disable appeared on\n */\nvar addDisableAll = function (toggledRules, line, column) {\n  toggledRules.globalEnable\n    .push([false, line, column]);\n};\n\n/**\n * Adds a globally enabled flag to the toggled rules globalEnable property including the line and column\n * that this comment was encountered on.\n *\n * @param {Object} toggledRules - Contains the information about the global enable comment\n                                  encountered and and what line/column it occurred on\n * @param {number} line - The line number the enable appeared on\n * @param {number} column - The column number the enable appeared on\n */\nvar addEnableAll = function (toggledRules, line, column) {\n  toggledRules.globalEnable\n    .push([true, line, column]);\n};\n\n/**\n * Adds a line disabled flag to the ruleEnable property of the toggledRules object for each rule name\n * encountered in the comment and which line this comment was discovered on / refers to\n *\n * @param {Object} toggledRules - Contains the information about the line disable comment encountered, the rules\n *                              it relates to and which line it was encountered on\n * @param {Array} rules - An array of rule names to apply\n * @param {number} line - The line number that this disable should refer to\n */\nvar addDisableLine = function (toggledRules, rules, line) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    // NOTE: corner case not handled here: a 2nd disable inside an ignored line, which is unrealistically pathological.\n    toggledRules.ruleEnable[rule].push([false, line, 1]);\n    toggledRules.ruleEnable[rule].push([true, line + 1, 1]);\n  });\n};\n\n/**\n * This is the sorting function we use to sort the toggle stacks in our getToggledRules method\n * First sorts by line and then by column if the lines are identical\n *\n * @param {Array} toggleRangeA - The first rule to sort\n * @param {Array} toggleRangeB - The second rule to sort\n *\n * @returns {number} A pointer to signify to the sort method how the currently in focus value should be sorted\n */\nvar sortRange = function (toggleRangeA, toggleRangeB) {\n  var aLine = toggleRangeA[1],\n      aCol = toggleRangeA[2],\n      bLine = toggleRangeB[1],\n      bCol = toggleRangeB[2];\n  if (aLine < bLine) {\n    return -1;\n  }\n  if (aLine > bLine) {\n    return 1;\n  }\n  if (aCol < bCol) {\n    return -1;\n  }\n  if (aCol > bCol) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * Checks if line number A is before line number B, if it's the same then it checks if the column of A\n * is before the column of B\n *\n * @param {number} x - The line number of A\n * @param {number} y - The column number of A\n * @param {number} x2 - The line number of B\n * @param {number} y2 - The column number of B\n *\n * @returns {Boolean} Whether the current line/column A is before or the same as B\n */\nvar isBeforeOrSame = function (x, y, x2, y2) {\n  return x < x2 || (x === x2 && y < y2);\n};\n\n/**\n * Traverses the AST looking for sass-lint disable/enable comments and then builds an Object/node representation\n * of any it encounters\n *\n * @param {Object} ast - Gonzales PE abstract syntax tree\n *\n * @returns {Object} The toggledRules object containing all of our rule enable/disable information\n */\nmodule.exports.getToggledRules = function (ast) {\n  var toggledRules = {\n    ruleEnable: {\n      // Format in here is [isEnabled, line, column]\n    },\n    globalEnable: []\n  };\n  if (!ast.traverseByTypes) {\n    return toggledRules;\n  }\n  ast.traverseByTypes(['multilineComment', 'singlelineComment'], function (comment, i, parent) {\n    var content = comment.content;\n    if (!content) {\n      return;\n    }\n    var tokens = content.split(/[\\s,]+/)\n      .filter(function (s) {\n        return s.trim().length > 0;\n      });\n    if (!tokens.length) {\n      return;\n    }\n    var first = tokens[0],\n        rules = tokens.slice(1);\n    switch (first) {\n    case 'sass-lint:disable':\n      addDisable(toggledRules, rules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:enable':\n      addEnable(toggledRules, rules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:disable-block':\n      // future ref: not sure what the appropriate behavior is if there is no parent block; currently NPEs\n      addDisableBlock(toggledRules, rules, parent);\n      break;\n    case 'sass-lint:disable-all':\n      addDisableAll(toggledRules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:enable-all':\n      addEnableAll(toggledRules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:disable-line':\n      addDisableLine(toggledRules, rules, comment.start.line);\n      break;\n    default:\n      return;\n    }\n  });\n  // Sort these toggle stacks so reading them is easier (algorithmically).\n  // Usually already sorted but since it's not guaranteed by the contract with gonzales-pe, ensuring it is.\n  toggledRules.globalEnable.sort(sortRange);\n  Object.keys(toggledRules.ruleEnable).map(function (ruleId) {\n    toggledRules.ruleEnable[ruleId].sort(sortRange);\n  });\n  return toggledRules;\n};\n\n/**\n * Filters our rule results by checking the lint result and its line/column against our\n * toggledRules object to see whether we should still be reporting this lint.\n *\n * @param {Object} toggledRules - The toggledRules object containing all of our rule enable/disable information\n *\n * @returns {Boolean} Whether the current rule is disabled for this lint report\n */\nmodule.exports.isResultEnabled = function (toggledRules) {\n  return function (ruleResult) {\n    var ruleId = ruleResult.ruleId;\n    // Convention: if no column or line, assume rule is targetting 1.\n    var line = ruleResult.line || 1;\n    var column = ruleResult.column || 1;\n    var isGloballyEnabled = toggledRules.globalEnable\n      .reduce(function (acc, toggleRange) {\n        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])\n          ? acc\n          : toggleRange[0];\n      }, true);\n    if (!isGloballyEnabled) {\n      return false;\n    }\n    if (!toggledRules.ruleEnable[ruleId]) {\n      return true;\n    }\n    var isRuleEnabled = toggledRules.ruleEnable[ruleId]\n      .reduce(function (acc, toggleRange) {\n        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])\n          ? acc\n          : toggleRange[0];\n      }, true);\n    if (!isRuleEnabled) {\n      return false;\n    }\n    return true;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/selector-helpers.js":"'use strict';\n\n// ==============================================================================\n//  Helpers\n// ==============================================================================\n\nvar simpleIdents = [\n  'ident',\n  'number',\n  'operator',\n  'combinator',\n  'string',\n  'parentSelector',\n  'delimiter',\n  'typeSelector',\n  'attributeMatch'\n];\n\nvar subSelectors = [\n  'parentSelectorExtension',\n  'attributeName',\n  'attributeValue',\n  'dimension',\n  'selector',\n  'function'\n];\n\n/**\n * Adds grammar around our content blocks to construct selectors with\n * more readable formats.\n *\n * @param {object} val - The current value node\n * @param {string} prefix - The grammar to prefix the value with\n * @param {string} suffix - The grammar to add after the value\n * @returns {string} The correct readable format\n */\nvar addGrammar = function (val, prefix, suffix) {\n  return prefix + val.content + suffix;\n};\n\n/**\n * Adds grammar around our content blocks to construct selectors with\n * more readable formats and loops the content as they're within sub blocks.\n *\n * @param {object} val - The current value node\n * @param {string} prefix - The grammar to prefix the value with\n * @param {string} suffix - The grammar to add after the value\n * @param {function} constructSelector - The callback we wish to use which means constructSelector in this instance\n * @returns {string} The correct readable format\n */\nvar constructSubSelector = function (val, prefix, suffix, constructSelector) {\n  var content = prefix;\n  val.forEach(function (subItem) {\n    content += constructSelector(subItem);\n  });\n\n  return content + suffix;\n};\n\n// ==============================================================================\n//  Public Methods\n// ==============================================================================\n\n/**\n * Constructs a syntax complete selector for our selector matching and warning output\n *\n * @param {object} val - The current node / part of our selector\n * @returns {string} - Content: The current node with correct syntax e.g. class my-class = '.my-class'\n */\nvar constructSelector = function (val) {\n  var content = null;\n\n  if (val.is('arguments')) {\n    content = constructSubSelector(val, '(', ')', constructSelector);\n  }\n\n  else if (val.is('atkeyword')) {\n    content = constructSubSelector(val, '@', '', constructSelector);\n  }\n\n  else if (val.is('attributeSelector')) {\n    content = constructSubSelector(val, '[', ']', constructSelector);\n  }\n\n  else if (val.is('class')) {\n    content = addGrammar(val, '.', '');\n  }\n\n  else if (val.is('id')) {\n    content = addGrammar(val, '#', '');\n  }\n\n  else if (val.is('interpolation')) {\n    content = constructSubSelector(val, '#{', '}', constructSelector);\n  }\n\n  else if (val.is('nth')) {\n    content = addGrammar(val, '(', ')');\n  }\n\n  else if (val.is('nthSelector')) {\n    content = constructSubSelector(val, ':', '', constructSelector);\n  }\n\n  else if (val.is('parentheses')) {\n    content = constructSubSelector(val, '(', ')', constructSelector);\n  }\n\n  else if (val.is('placeholder')) {\n    content = constructSubSelector(val, '%', '', constructSelector);\n  }\n\n  else if (val.is('pseudoClass')) {\n    content = constructSubSelector(val, ':', '', constructSelector);\n  }\n\n  else if (val.is('pseudoElement')) {\n    content = addGrammar(val, '::', '');\n  }\n\n  else if (val.is('space')) {\n    content = ' ';\n  }\n\n  else if (val.is('variable')) {\n    content = constructSubSelector(val, '$', '', constructSelector);\n  }\n\n  else if (simpleIdents.indexOf(val.type) !== -1) {\n    content = val.content;\n  }\n\n  else if (subSelectors.indexOf(val.type) !== -1) {\n    content = constructSubSelector(val, '', '', constructSelector);\n  }\n\n  return content;\n};\n\nmodule.exports = {\n  constructSelector: constructSelector\n};\n"}