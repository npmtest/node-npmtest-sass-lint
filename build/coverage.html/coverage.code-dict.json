{"/home/travis/build/npmtest/node-npmtest-sass-lint/test.js":"/* istanbul instrument in package npmtest_sass_lint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sass-lint/lib.npmtest_sass_lint.js":"/* istanbul instrument in package npmtest_sass_lint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sass_lint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sass_lint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sass-lint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sass-lint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sass_lint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sass_lint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sass_lint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sass_lint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sass_lint.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sass_lint.__dirname + '/lib.npmtest_sass_lint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/index.js":"'use strict';\n\nvar slConfig = require('./lib/config'),\n    groot = require('./lib/groot'),\n    exceptions = require('./lib/exceptions'),\n    helpers = require('./lib/helpers'),\n    slRules = require('./lib/rules'),\n    ruleToggler = require('./lib/ruleToggler'),\n    glob = require('glob'),\n    path = require('path'),\n    fs = require('fs-extra'),\n    globule = require('globule');\n\nvar getToggledRules = ruleToggler.getToggledRules,\n    isResultEnabled = ruleToggler.isResultEnabled;\n\nvar sassLint = function (config) { // eslint-disable-line no-unused-vars\n  config = require('./lib/config')(config);\n  return;\n};\n\n/**\n * Takes any user specified options and a configPath\n * which returns a compiled config object\n *\n * @param {object} config user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} the compiled config object\n */\nsassLint.getConfig = function (config, configPath) {\n  return slConfig(config, configPath);\n};\n\n/**\n * Parses our results object to count errors and return\n * paths to files with detected errors.\n *\n * @param {object} results our results object\n * @returns {object} errors object containing the error count and paths for files incl. errors\n */\nsassLint.errorCount = function (results) {\n  var errors = {\n    count: 0,\n    files: []\n  };\n\n  results.forEach(function (result) {\n    if (result.errorCount) {\n      errors.count += result.errorCount;\n      errors.files.push(result.filePath);\n    }\n  });\n\n  return errors;\n};\n\n/**\n * Parses our results object to count warnings and return\n * paths to files with detected warnings.\n *\n * @param {object} results our results object\n * @returns {object} warnings object containing the error count and paths for files incl. warnings\n */\nsassLint.warningCount = function (results) {\n  var warnings = {\n    count: 0,\n    files: []\n  };\n\n  results.forEach(function (result) {\n    if (result.warningCount) {\n      warnings.count += result.warningCount;\n      warnings.files.push(result.filePath);\n    }\n  });\n\n  return warnings;\n};\n\n/**\n * Parses our results object to count warnings and errors and return\n * a cumulative count of both\n *\n * @param {object} results our results object\n * @returns {int} the cumulative count of errors and warnings detected\n */\nsassLint.resultCount = function (results) {\n  var warnings = this.warningCount(results),\n      errors = this.errorCount(results);\n\n  return warnings.count + errors.count;\n};\n\n/**\n * Runs each rule against our AST tree and returns our main object of detected\n * errors, warnings, messages and filenames.\n *\n * @param {object} file file object from fs.readFileSync\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} an object containing error & warning counts plus lint messages for each parsed file\n */\nsassLint.lintText = function (file, options, configPath) {\n  var rules = slRules(this.getConfig(options, configPath)),\n      ast = {},\n      detects,\n      results = [],\n      errors = 0,\n      warnings = 0,\n      ruleToggles = null,\n      isEnabledFilter = null;\n\n  try {\n    ast = groot(file.text, file.format, file.filename);\n  }\n  catch (e) {\n    var line = e.line || 1;\n    errors++;\n\n    results = [{\n      ruleId: 'Fatal',\n      line: line,\n      column: 1,\n      message: e.message,\n      severity: 2\n    }];\n  }\n\n  if (ast.content && ast.content.length > 0) {\n    ruleToggles = getToggledRules(ast);\n    isEnabledFilter = isResultEnabled(ruleToggles);\n\n    rules.forEach(function (rule) {\n      detects = rule.rule.detect(ast, rule)\n        .filter(isEnabledFilter);\n      results = results.concat(detects);\n      if (detects.length) {\n        if (rule.severity === 1) {\n          warnings += detects.length;\n        }\n        else if (rule.severity === 2) {\n          errors += detects.length;\n        }\n      }\n    });\n  }\n\n  results.sort(helpers.sortDetects);\n\n  return {\n    'filePath': file.filename,\n    'warningCount': warnings,\n    'errorCount': errors,\n    'messages': results\n  };\n};\n\n/**\n * Handles ignored files for plugins such as the gulp plugin. Checks every file passed to it against\n * the ignores as specified in our users config or passed in options.\n *\n * @param {object} file - The file/text to be linted\n * @param {object} options - The user defined options directly passed in\n * @param {object} configPath - Path to a config file\n * @returns {object} Return the results of lintText - a results object\n */\nsassLint.lintFileText = function (file, options, configPath) {\n  var config = this.getConfig(options, configPath),\n      ignores = config.files ? config.files.ignore : [];\n\n  if (!globule.isMatch(ignores, file.filename)) {\n    return this.lintText(file, options, configPath);\n  }\n\n  return {\n    'filePath': file.filename,\n    'warningCount': 0,\n    'errorCount': 0,\n    'messages': []\n  };\n};\n\n/**\n * Takes a glob pattern or target string and creates an array of files as targets for\n * linting taking into account any user specified ignores. For each resulting file sassLint.lintText\n * is called which returns an object of results for that file which we push to our results object.\n *\n * @param {string} files a glob pattern or single file path as a lint target\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} results object containing all results\n */\nsassLint.lintFiles = function (files, options, configPath) {\n  var that = this,\n      results = [],\n      includes = [],\n      ignores = '';\n\n  // Files passed as a string on the command line\n  if (files) {\n    ignores = this.getConfig(options, configPath).files.ignore || '';\n    if (files.indexOf(', ') !== -1) {\n      files.split(', ').forEach(function (pattern) {\n        includes = includes.concat(glob.sync(pattern, {ignore: ignores, nodir: true}));\n      });\n    }\n    else {\n      includes = glob.sync(files, {ignore: ignores, nodir: true});\n    }\n  }\n  // If not passed in then we look in the config file\n  else {\n    files = this.getConfig(options, configPath).files;\n    // A glob pattern of files can be just a string\n    if (typeof files === 'string') {\n      includes = glob.sync(files, {nodir: true});\n    }\n    // Look into the include property of files and check if there's an array of files\n    else if (files.include && files.include instanceof Array) {\n      files.include.forEach(function (pattern) {\n        includes = includes.concat(glob.sync(pattern, {ignore: files.ignore, nodir: true}));\n      });\n    }\n    // Or there is only one pattern in the include property of files\n    else {\n      includes = glob.sync(files.include, {ignore: files.ignore, nodir: true});\n    }\n  }\n\n  includes.forEach(function (file, index) {\n    // Only lint non duplicate files from our glob results\n    if (includes.indexOf(file) === index) {\n      var lint = that.lintText({\n        'text': fs.readFileSync(file),\n        'format': options.syntax ? options.syntax : path.extname(file).replace('.', ''),\n        'filename': file\n      }, options, configPath);\n      results.push(lint);\n    }\n  });\n\n  return results;\n};\n\n/**\n * Handles formatting of results using EsLint formatters\n *\n * @param {object} results our results object\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} results our results object in the user specified format\n */\nsassLint.format = function (results, options, configPath) {\n  var config = this.getConfig(options, configPath),\n      format = config.options.formatter.toLowerCase();\n\n  var formatted = require('eslint/lib/formatters/' + format);\n\n  return formatted(results);\n};\n\n/**\n * Handles outputting results whether this be straight to the console/stdout or to a file.\n * Passes results to the format function to ensure results are output in the chosen format\n *\n * @param {object} results our results object\n * @param {object} options user specified rules/options passed in\n * @param {string} configPath path to a config file\n * @returns {object} results our results object\n */\nsassLint.outputResults = function (results, options, configPath) {\n  var config = this.getConfig(options, configPath);\n\n  if (this.resultCount(results)) {\n\n    var formatted = this.format(results, options, configPath);\n\n    if (config.options['output-file']) {\n      try {\n        fs.outputFileSync(path.resolve(process.cwd(), config.options['output-file']), formatted);\n        console.log('Output successfully written to ' + path.resolve(process.cwd(), config.options['output-file']));\n      }\n      catch (e) {\n        console.log('Error: Output was unable to be written to ' + path.resolve(process.cwd(), config.options['output-file']));\n      }\n    }\n    else {\n      console.log(formatted);\n    }\n  }\n  return results;\n};\n\n/**\n * Throws an error if there are any errors detected. The error includes a count of all errors\n * and a list of all files that include errors.\n *\n * @param {object} results - our results object\n * @param {object} [options] - extra options to use when running failOnError, e.g. max-warnings\n * @param {string} [configPath] - path to the config file\n * @returns {void}\n */\nsassLint.failOnError = function (results, options, configPath) {\n  // Default parameters\n  options = typeof options !== 'undefined' ? options : {};\n  configPath = typeof configPath !== 'undefined' ? configPath : null;\n\n  var errorCount = this.errorCount(results),\n      warningCount = this.warningCount(results),\n      configOptions = this.getConfig(options, configPath).options;\n\n  if (errorCount.count > 0) {\n    throw new exceptions.SassLintFailureError(errorCount.count + ' errors were detected in \\n- ' + errorCount.files.join('\\n- '));\n  }\n\n  if (!isNaN(configOptions['max-warnings']) && warningCount.count > configOptions['max-warnings']) {\n    throw new exceptions.MaxWarningsExceededError(\n      'Number of warnings (' + warningCount.count +\n      ') exceeds the allowed maximum of ' + configOptions['max-warnings'] +\n      '.\\n'\n    );\n  }\n};\n\nmodule.exports = sassLint;\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/config.js":"'use strict';\n\nvar path = require('path'),\n    merge = require('merge'),\n    confHelpers = require('./config-helpers'),\n    pathIsAbsolute = require('path-is-absolute');\n\nvar cacheConfig = {},\n    cacheEnabled = false;\n\nmodule.exports = function (options, configPath) {\n  var meta = null,\n      metaPath,\n      configMerge = false,\n      configMergeExists = false,\n      optionsMerge = false,\n      optionsMergeExists = false,\n      finalCacheExists = false,\n      config = {},\n      finalConfig = {},\n      defaults;\n\n  // ensure our inline options and rules are not undefined\n  options = options ? options : {};\n  options.rules = options.rules ? options.rules : {};\n\n  // ensure our user defined cache option is respected\n  if (options.options && options.options.hasOwnProperty('cache-config')) {\n    if (options.options['cache-config'] && Object.keys(cacheConfig).length) {\n      return cacheConfig;\n    }\n  }\n  else {\n    // check to see if the config cache already exists and is enabled\n    if (cacheEnabled && Object.keys(cacheConfig).length) {\n      return cacheConfig;\n    }\n  }\n\n  if (options.options && options.options['config-file']) {\n    configPath = options.options['config-file'];\n  }\n\n  if (!configPath) {\n    metaPath = confHelpers.findFile(false, 'package.json');\n    if (metaPath) {\n      meta = require(metaPath);\n    }\n\n    if (meta && meta.sasslintConfig) {\n      configPath = path.resolve(path.dirname(metaPath), meta.sasslintConfig);\n    }\n    else {\n      configPath = confHelpers.findFile(false, '.sass-lint.yml');\n    }\n  }\n  else if (!pathIsAbsolute(configPath)) {\n    configPath = path.resolve(process.cwd(), configPath);\n  }\n\n  config = confHelpers.loadConfig(configPath);\n  config = confHelpers.checkForConfigExtend(config, configPath);\n\n  // check to see if user config contains an options property and whether property has a property called merge-default-rules\n  configMergeExists = (config.options && typeof config.options['merge-default-rules'] !== 'undefined');\n\n  // If it does then retrieve the value of it here or return false\n  configMerge = configMergeExists ? config.options['merge-default-rules'] : false;\n\n  // check to see if inline options contains an options property and whether property has a property called merge-default-rules\n  optionsMergeExists = (options.options && typeof options.options['merge-default-rules'] !== 'undefined');\n\n  // If it does then retrieve the value of it here or return false\n  optionsMerge = optionsMergeExists ? options.options['merge-default-rules'] : false;\n\n\n  // order of preference is inline options > user config > default config\n  // merge-default-rules defaults to true so each step above should merge with the previous. If at any step merge-default-rules is set to\n  // false it should skip that steps merge.\n  defaults = confHelpers.loadDefaults();\n  finalConfig = merge.recursive(defaults, config, options);\n\n  // if merge-default-rules is set to false in user config file then we essentially skip the merging with default rules by overwriting our\n  // final rules with the content of our user config otherwise we don't take action here as the default merging has already happened\n  if (configMergeExists && !configMerge) {\n    finalConfig.rules = config.rules;\n  }\n\n  // if merge-default-rules is set to false in inline options we essentially skip the merging with our current rules by overwriting our\n  // final rules with the content of our user config otherwise we check to see if merge-default-rules is true OR that we have any inline\n  // rules, if we do then we want to merge these into our final ruleset.\n  if (optionsMergeExists && !optionsMerge) {\n    finalConfig.rules = options.rules;\n  }\n  else if ((optionsMergeExists && optionsMerge) || options.rules && Object.keys(options.rules).length > 0) {\n    finalConfig.rules = merge.recursive(finalConfig.rules, options.rules);\n  }\n\n  // check to see if our final config contains a cache-config value\n  finalCacheExists = (finalConfig.options && typeof finalConfig.options['cache-config'] !== 'undefined');\n\n  // set our global cache enabled flag here, it will be false by default\n  cacheEnabled = finalCacheExists ? finalConfig.options['cache-config'] : false;\n\n  // set our cached config to our final config\n  cacheConfig = cacheEnabled ? finalConfig : {};\n\n  return finalConfig;\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/config-helpers.js":"var yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path'),\n    merge = require('merge'),\n    pathIsAbsolute = require('path-is-absolute');\n\n/**\n * Loads the default sass-lint configuration file\n *\n * @returns {Object} The default sass-lint configuration\n */\nvar loadDefaults = function loadDefaults () {\n  return yaml.safeLoad(fs.readFileSync(path.join(__dirname, 'config', 'sass-lint.yml'), 'utf8'));\n};\n\n/**\n * Attempts to traverse the tree looking for the specified file\n *\n * @param {String} configPath - The path to look for the file.\n * @param {String} filename - The name of the file.\n * @returns {String} The resolved path\n */\nvar findFile = function findFile (configPath, filename) {\n  var HOME = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE,\n      dirname = null,\n      parentDirname = null;\n\n  configPath = configPath || path.join(process.cwd(), filename);\n\n  if (configPath && fs.existsSync(configPath)) {\n    return fs.realpathSync(configPath);\n  }\n  dirname = path.dirname(configPath);\n  parentDirname = path.dirname(dirname);\n\n  if (dirname === null || dirname === HOME || dirname === parentDirname) {\n    return null;\n  }\n  configPath = path.join(parentDirname, filename);\n\n  return findFile(configPath, filename);\n};\n\n/**\n * Loads a config file from a specified path if it exists. The resolved config will be returned\n * or a blank config will be in it's place.\n *\n * @param {String} cPath - The path to the config file\n * @returns {Object} The configuration object\n */\nvar loadConfig = function (cPath) {\n  var configPath = cPath,\n      resolvedConfig = {};\n\n  if (configPath) {\n    if (fs.existsSync(configPath)) {\n      resolvedConfig = yaml.safeLoad(fs.readFileSync(configPath, 'utf8')) || {};\n    }\n  }\n\n  return {\n    options: resolvedConfig.options || {},\n    files: resolvedConfig.files || {},\n    rules: resolvedConfig.rules || {}\n  };\n};\n\n/**\n * Checks a config file to see if another config file is specified, if it is, the file is laoded\n * and merged with the current configuration object.\n *\n * @param {Object} config - The current configuration\n * @param {String} curConfPath - The current path(incl filename) to the configuration object passed as 'config'\n * @returns {Object} The merged configuration object\n */\nvar checkForConfigExtend = function (config, curConfPath) {\n  var mergedConfig = config,\n      subConfig = config.options['config-file'] || false,\n      confPath,\n      resolvedSubConfig;\n\n  if (subConfig) {\n    if (!pathIsAbsolute(subConfig)) {\n      // Process.cwd() in most IDE's will be / so therefore we need to pass the current directory\n      // of the config from which you are 'extending' or we resort to process.cwd() which on the CLI\n      // will be correct\n      confPath = curConfPath ? path.dirname(curConfPath) : process.cwd();\n      subConfig = path.resolve(confPath, subConfig);\n    }\n    // Attempt to load the new found config file\n    resolvedSubConfig = loadConfig(subConfig, curConfPath);\n    // Check the new config file to see if it too is extending\n    resolvedSubConfig = checkForConfigExtend(resolvedSubConfig, subConfig);\n    // Merge our configs with the first encountered being the most important, down to the last config\n    // being the least.\n    mergedConfig = merge.recursive(resolvedSubConfig, config);\n  }\n\n  return mergedConfig;\n};\n\nmodule.exports = {\n  loadDefaults: loadDefaults,\n  findFile: findFile,\n  loadConfig: loadConfig,\n  checkForConfigExtend: checkForConfigExtend\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/groot.js":"//////////////////////////////\n// Tree Abstraction\n//////////////////////////////\n'use strict';\n\nvar gonzales = require('gonzales-pe');\nvar fm = require('front-matter');\nvar helpers = require('./helpers');\n\nmodule.exports = function (text, syntax, filename) {\n  var tree;\n\n  // Run `.toString()` to allow Buffers to be passed in\n  text = helpers.stripBom(text.toString());\n\n  // if we're skipping front matter do it here, fall back to just our text in case it fails\n  if (fm.test(text)) {\n    text = fm(text).body || text;\n  }\n\n  try {\n    tree = gonzales.parse(text, {\n      'syntax': syntax\n    });\n  }\n  catch (e) {\n    throw {\n      message: e.message,\n      file: filename,\n      line: e.line\n    };\n  }\n\n  if (typeof tree === 'undefined') {\n    throw {\n      message: 'Undefined tree',\n      file: filename,\n      text: text.toString(),\n      tree: tree.toString()\n    };\n  }\n\n  return tree;\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/helpers.js":"'use strict';\n\nvar util = require('util'),\n    fs = require('fs'),\n    path = require('path'),\n    yaml = require('js-yaml'),\n    gonzales = require('gonzales-pe');\n\nvar helpers = {};\n\nhelpers.log = function log (input) {\n  console.log(util.inspect(input, false, null));\n};\n\nhelpers.propertySearch = function (haystack, needle, property) {\n  var length = haystack.length,\n      i;\n\n  for (i = 0; i < length; i++) {\n    if (haystack[i][property] === needle) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nhelpers.isEqual = function (a, b) {\n  var startLine = a.start.line === b.start.line ? true : false,\n      endLine = a.end.line === b.end.line ? true : false,\n      type = a.type === b.type ? true : false,\n      length = a.content.length === b.content.length ? true : false;\n\n  if (startLine && endLine && type && length) {\n    return true;\n  }\n  else {\n    return false;\n  }\n};\n\nhelpers.isUnique = function (results, item) {\n  var search = this.propertySearch(results, item.line, 'line');\n\n  if (search === -1) {\n    return true;\n  }\n  else if (results[search].column === item.column && results[search].message === item.message) {\n    return false;\n  }\n  else {\n    return true;\n  }\n};\n\nhelpers.addUnique = function (results, item) {\n  if (this.isUnique(results, item)) {\n    results.push(item);\n  }\n  return results;\n};\n\nhelpers.sortDetects = function (a, b) {\n  if (a.line < b.line) {\n    return -1;\n  }\n  if (a.line > b.line) {\n    return 1;\n  }\n  if (a.line === b.line) {\n    if (a.column < b.column) {\n      return -1;\n    }\n    if (a.column > b.column) {\n      return 1;\n    }\n    return 0;\n  }\n  return 0;\n};\n\nhelpers.isNumber = function (val) {\n  if (isNaN(parseInt(val, 10))) {\n    return false;\n  }\n  return true;\n};\n\nhelpers.isUpperCase = function (str) {\n  var pieces = str.split(''),\n      i,\n      result = 0;\n\n  for (i = 0; i < pieces.length; i++) {\n    if (!helpers.isNumber(pieces[i])) {\n      if (pieces[i] === pieces[i].toUpperCase() && pieces[i] !== pieces[i].toLowerCase()) {\n        result++;\n      }\n      else {\n        return false;\n      }\n    }\n  }\n  if (result) {\n    return true;\n  }\n  return false;\n};\n\nhelpers.isLowerCase = function (str) {\n  var pieces = str.split(''),\n      i,\n      result = 0;\n\n  for (i = 0; i < pieces.length; i++) {\n    if (!helpers.isNumber(pieces[i])) {\n      if (pieces[i] === pieces[i].toLowerCase() && pieces[i] !== pieces[i].toUpperCase()) {\n        result++;\n      }\n      else {\n        return false;\n      }\n    }\n  }\n  if (result) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Determines if a given string adheres to camel-case format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to camel-case format\n */\nhelpers.isCamelCase = function (str) {\n  return /^[a-z][a-zA-Z0-9]*$/.test(str);\n};\n\n/**\n * Determines if a given string adheres to pascal-case format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to pascal-case format\n */\nhelpers.isPascalCase = function (str) {\n  return /^[A-Z][a-zA-Z0-9]*$/.test(str);\n};\n\n/**\n * Determines if a given string adheres to hyphenated-lowercase format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to hyphenated-lowercase format\n */\nhelpers.isHyphenatedLowercase = function (str) {\n  return !(/[^\\-a-z0-9]/.test(str));\n};\n\n/**\n * Determines if a given string adheres to snake-case format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to snake-case format\n */\nhelpers.isSnakeCase = function (str) {\n  return !(/[^_a-z0-9]/.test(str));\n};\n\n/**\n * Determines if a given string adheres to strict-BEM format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to strict-BEM format\n */\nhelpers.isStrictBEM = function (str) {\n  return /^[a-z](\\-?[a-z0-9]+)*(__[a-z0-9](\\-?[a-z0-9]+)*)?((_[a-z0-9](\\-?[a-z0-9]+)*){0,2})?$/.test(str);\n};\n\n/**\n * Determines if a given string adheres to hyphenated-BEM format\n * @param   {string}  str String to test\n * @returns {boolean}     Whether str adheres to hyphenated-BEM format\n */\nhelpers.isHyphenatedBEM = function (str) {\n  return !(/[A-Z]|-{3}|_{3}|[^_]_[^_]/.test(str));\n};\n\nhelpers.isValidHex = function (str) {\n  if (str.match(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a node is a newline character or not\n *\n * @param {Object} node - The node to test\n * @returns {boolean} Whether the node is a newline or not\n */\nhelpers.isNewLine = function (node) {\n  // using type === instead of is just in case node happens to be a string\n  return !!(node && node.type === 'space' && node.content.match('\\n'));\n};\n\n/**\n * Check if a node is a non newline space character or not\n *\n * @param {Object} node - The node to test\n * @returns {boolean} Whether the node is a non newline space or not\n */\nhelpers.isSpace = function (node) {\n  return !!(node && node.type === 'space' && !node.content.match('\\n'));\n};\n\nhelpers.loadConfigFile = function (configPath) {\n  var fileDir = path.dirname(configPath),\n      fileName = path.basename(configPath),\n      fileExtension = path.extname(fileName),\n      filePath = path.join(__dirname, 'config', fileDir, fileName),\n      file = fs.readFileSync(filePath, 'utf8') || false;\n\n  if (file) {\n    if (fileExtension === '.yml') {\n      return yaml.safeLoad(file);\n    }\n  }\n\n  return file;\n};\n\nhelpers.hasEOL = function (str) {\n  return /\\r\\n|\\n/.test(str);\n};\n\nhelpers.isEmptyLine = function (str) {\n  return /(\\r\\n|\\n){2}/.test(str);\n};\n\nhelpers.stripQuotes = function (str) {\n  return str.substring(1, str.length - 1);\n};\n\n/**\n * Strips vendor prefixes from a string\n *\n * @param {string} str - The string we wish to remove vendor prefixes from\n * @returns {string} The string without vendor prefixes\n */\nhelpers.stripPrefix = function (str) {\n  var modPropertyArr = str.split('-'),\n      modProperty = '',\n      prefLength = modPropertyArr[2] === 'osx' ? 2 : 1;\n\n  modPropertyArr.splice(1, prefLength);\n\n  modPropertyArr.forEach(function (item, index) {\n    modProperty = modProperty + item;\n    if (index > 0 && index < modPropertyArr.length - 1) {\n      modProperty = modProperty + '-';\n    }\n  });\n\n  return modProperty;\n};\n\n/**\n * Removes the trailing space from a string\n * @param {string} curSelector - the current selector string\n * @returns {string} curSelector - the current selector minus any trailing space.\n */\n\nhelpers.stripLastSpace = function (selector) {\n\n  if (selector.charAt(selector.length - 1) === ' ') {\n    return selector.substr(0, selector.length - 1);\n\n  }\n\n  return selector;\n\n};\n\n/**\n * Checks the current selector value against the previous selector value and assesses whether they are\n * a) currently an enforced selector type for nesting (user specified - all true by default)\n * b) whether they should be nested\n * @param {object} currentVal - the current node / part of our selector\n * @param {object} previousVal - the previous node / part of our selector\n * @param {array} elements - a complete array of nestable selector types\n * @param {array} nestable - an array of the types of selector to nest\n * @returns {object} Returns whether we or we should nest and the previous val\n */\nhelpers.isNestable = function (currentVal, previousVal, elements, nestable) {\n  // check if they are nestable by checking the previous element against one\n  // of the user specified selector types\n  if (elements.indexOf(previousVal) !== -1 && nestable.indexOf(currentVal) !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Tries to traverse the AST, following a specified path\n * @param   {object}  node           Starting node\n * @param   {array}   traversalPath  Array of Node types to traverse, starting from the first element\n * @returns {array}                  Nodes at the end of the path. Empty array if the traversal failed\n */\nhelpers.attemptTraversal = function (node, traversalPath) {\n  var i,\n      nextNodeList,\n      currentNodeList = [],\n      processChildNode = function processChildNode (child) {\n        child.forEach(traversalPath[i], function (n) {\n          nextNodeList.push(n);\n        });\n      };\n\n  node.forEach(traversalPath[0], function (n) {\n    currentNodeList.push(n);\n  });\n\n  for (i = 1; i < traversalPath.length; i++) {\n    if (currentNodeList.length === 0) {\n      return [];\n    }\n\n    nextNodeList = [];\n    currentNodeList.forEach(processChildNode);\n    currentNodeList = nextNodeList;\n  }\n  return currentNodeList;\n};\n\n/**\n * Collects all suffix extensions for a selector\n * @param   {object}  ruleset      ASTNode of type ruleset, containing a selector with nested suffix extensions\n * @param   {string}  selectorType Node type of the selector (e.g. class, id)\n * @returns {array}                Array of Nodes with the content property replaced by the complete selector\n *                                       (without '.', '#', etc) resulting from suffix extensions\n */\nhelpers.collectSuffixExtensions = function (ruleset, selectorType) {\n  var parentSelectors = helpers.attemptTraversal(ruleset, ['selector', selectorType, 'ident']),\n      childSuffixes = helpers.attemptTraversal(ruleset, ['block', 'ruleset']),\n      selectorList = [];\n\n  if (parentSelectors.length === 0) {\n    return [];\n  }\n\n  // Goes recursively through all nodes that look like suffix extensions. There may be multiple parents that are\n  // extended, so lots of looping is required.\n  var processChildSuffix = function (child, parents) {\n    var currentParents = [],\n        selectors = helpers.attemptTraversal(child, ['selector', 'parentSelectorExtension', 'ident']),\n        nestedChildSuffixes = helpers.attemptTraversal(child, ['block', 'ruleset']);\n\n    selectors.forEach(function (childSuffixNode) {\n      // append suffix extension to all parent selectors\n      parents.forEach(function (parent) {\n        // clone so we don't modify the actual AST\n        var clonedChildSuffixNode = gonzales.createNode(childSuffixNode);\n        clonedChildSuffixNode.content = parent.content + clonedChildSuffixNode.content;\n\n        currentParents.push(clonedChildSuffixNode);\n      });\n    });\n\n    selectorList = selectorList.concat(currentParents);\n\n    nestedChildSuffixes.forEach(function (childSuffix) {\n      processChildSuffix(childSuffix, currentParents);\n    });\n  };\n\n  childSuffixes.forEach(function (childSuffix) {\n    processChildSuffix(childSuffix, parentSelectors);\n  });\n\n  return parentSelectors.concat(selectorList);\n};\n\n/**\n * Check for the partial match of a string in an array\n *\n * @param {string} needle - The value to match\n * @param {Array} haystack - The array of values to try and match to\n * @returns {Boolean} Whether there is a partial match or not\n */\nhelpers.isPartialStringMatch = function (needle, haystack) {\n  for (var i = 0; i < haystack.length; i++) {\n    if (haystack[i].indexOf(needle) >= 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n *  A copy of the the stripBom module from https://github.com/sindresorhus/strip-bom/blob/master/index.js\n *  The module requires node > 4 whereas we support earlier versions.\n *  This function strips the BOM marker from the beginning of a file\n *\n * @param {string} str - The string we wish to strip the BOM marker from\n * @returns {string} The string without a BOM marker\n */\nhelpers.stripBom = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string, got ' + typeof str);\n  }\n\n  if (str.charCodeAt(0) === 0xFEFF) {\n    return str.slice(1);\n  }\n\n  return str;\n};\n\nmodule.exports = helpers;\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/exceptions.js":"'use strict';\n\nvar util = require('util');\n\nmodule.exports = {\n  SassLintFailureError: function (message) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = 'SassLintFailureError';\n    this.message = message;\n  },\n  MaxWarningsExceededError: function (message) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = 'MaxWarningsExceededError';\n    this.message = message;\n  }\n};\n\nutil.inherits(module.exports.SassLintFailureError, Error);\nutil.inherits(module.exports.MaxWarningsExceededError, Error);\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules.js":"'use strict';\n\nvar merge = require('merge'),\n    path = require('path'),\n    fs = require('fs');\n\nvar searchArray = function (haystack, needle) {\n  var i;\n  for (i = 0; i < haystack.length; i++) {\n    if (haystack[i].indexOf(needle) >= 0) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nmodule.exports = function (config) {\n  var handlers = [],\n      i,\n      rules;\n\n  rules = fs.readdirSync(path.join(__dirname, 'rules'));\n  for (i = 0; i < rules.length; i++) {\n    rules[i] = path.join(__dirname, 'rules', rules[i]);\n  }\n\n  Object.keys(config.rules).forEach(function (rule) {\n    var fullRule = config.rules[rule],\n        loadRule,\n        severity,\n        options,\n        ruleSearch;\n\n    if (typeof fullRule === 'number') {\n      severity = fullRule;\n      options = {};\n    }\n    else {\n      severity = fullRule[0];\n      options = fullRule[1];\n    }\n\n    // Only seek out rules that are enabled\n    if (severity !== 0) {\n      var fileName = path.normalize(path.join('/', rule + '.js'));\n\n      ruleSearch = searchArray(rules, fileName);\n\n      if (ruleSearch >= 0) {\n        loadRule = require(rules[ruleSearch]);\n\n        options = merge.recursive(true, loadRule.defaults, options);\n\n        handlers.push({\n          'rule': loadRule,\n          'severity': severity,\n          'options': options\n        });\n      }\n      else {\n        throw new Error('Rule `' + rule + '` could not be found!');\n      }\n    }\n  });\n\n  return handlers;\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/ruleToggler.js":"'use strict';\n\n/**\n * Adds each rule in our array of rules in a disable comment into the toggledRules object\n * under the correct rule name along with the line and column number where the disable comment\n * was encountered\n *\n * @param {Object} toggledRules - Contains the information about each rule disable/enable\n                                  encountered and and what line/column it occurred on\n * @param {Array} rules - An array of rule names\n * @param {number} line - The line number the disable appeared on\n * @param {number} column - The column number the disable appeared on\n */\nvar addDisable = function (toggledRules, rules, line, column) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    toggledRules.ruleEnable[rule].push([false, line, column]);\n  });\n};\n\n/**\n * Adds each rule in our array of rules in a enable comment into the toggledRules object\n * under the correct rule name along with the line and column number where the enable comment\n * was encountered\n *\n * @param {Object} toggledRules - Contains the information about each rule enable\n                                  encountered and and what line/column it occurred on\n * @param {Array} rules - An array of rule names\n * @param {number} line - The line number the enable appeared on\n * @param {number} column - The column number the enable appeared on\n */\nvar addEnable = function (toggledRules, rules, line, column) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    toggledRules.ruleEnable[rule].push([true, line, column]);\n  });\n};\n\n/**\n * Adds each rule in our array of rules in a disable block comment into the toggledRules object\n * under the correct rule name along with the line and column number where the disable block comment\n * was encountered\n *\n * @param {Object} toggledRules - Contains the information about each rule enable\n                                  encountered and and what line/column that block occurred on\n * @param {Array} rules - An array of rule names\n * @param {Object} block - The block that is to be disabled\n */\nvar addDisableBlock = function (toggledRules, rules, block) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    toggledRules.ruleEnable[rule].push([false, block.start.line, block.start.column]);\n    toggledRules.ruleEnable[rule].push([true, block.end.line, block.end.column]);\n  });\n};\n\n/**\n * Adds a globally disabled flag to the toggled rules globalEnable property including the line and column\n * that this comment was encountered on.\n *\n * @param {Object} toggledRules - Contains the information about the global disable comment\n                                  encountered and and what line/column it occurred on\n * @param {number} line - The line number the disable appeared on\n * @param {number} column - The column number the disable appeared on\n */\nvar addDisableAll = function (toggledRules, line, column) {\n  toggledRules.globalEnable\n    .push([false, line, column]);\n};\n\n/**\n * Adds a globally enabled flag to the toggled rules globalEnable property including the line and column\n * that this comment was encountered on.\n *\n * @param {Object} toggledRules - Contains the information about the global enable comment\n                                  encountered and and what line/column it occurred on\n * @param {number} line - The line number the enable appeared on\n * @param {number} column - The column number the enable appeared on\n */\nvar addEnableAll = function (toggledRules, line, column) {\n  toggledRules.globalEnable\n    .push([true, line, column]);\n};\n\n/**\n * Adds a line disabled flag to the ruleEnable property of the toggledRules object for each rule name\n * encountered in the comment and which line this comment was discovered on / refers to\n *\n * @param {Object} toggledRules - Contains the information about the line disable comment encountered, the rules\n *                              it relates to and which line it was encountered on\n * @param {Array} rules - An array of rule names to apply\n * @param {number} line - The line number that this disable should refer to\n */\nvar addDisableLine = function (toggledRules, rules, line) {\n  rules.map(function (rule) {\n    toggledRules.ruleEnable[rule] = toggledRules.ruleEnable[rule] || [];\n    // NOTE: corner case not handled here: a 2nd disable inside an ignored line, which is unrealistically pathological.\n    toggledRules.ruleEnable[rule].push([false, line, 1]);\n    toggledRules.ruleEnable[rule].push([true, line + 1, 1]);\n  });\n};\n\n/**\n * This is the sorting function we use to sort the toggle stacks in our getToggledRules method\n * First sorts by line and then by column if the lines are identical\n *\n * @param {Array} toggleRangeA - The first rule to sort\n * @param {Array} toggleRangeB - The second rule to sort\n *\n * @returns {number} A pointer to signify to the sort method how the currently in focus value should be sorted\n */\nvar sortRange = function (toggleRangeA, toggleRangeB) {\n  var aLine = toggleRangeA[1],\n      aCol = toggleRangeA[2],\n      bLine = toggleRangeB[1],\n      bCol = toggleRangeB[2];\n  if (aLine < bLine) {\n    return -1;\n  }\n  if (aLine > bLine) {\n    return 1;\n  }\n  if (aCol < bCol) {\n    return -1;\n  }\n  if (aCol > bCol) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * Checks if line number A is before line number B, if it's the same then it checks if the column of A\n * is before the column of B\n *\n * @param {number} x - The line number of A\n * @param {number} y - The column number of A\n * @param {number} x2 - The line number of B\n * @param {number} y2 - The column number of B\n *\n * @returns {Boolean} Whether the current line/column A is before or the same as B\n */\nvar isBeforeOrSame = function (x, y, x2, y2) {\n  return x < x2 || (x === x2 && y < y2);\n};\n\n/**\n * Traverses the AST looking for sass-lint disable/enable comments and then builds an Object/node representation\n * of any it encounters\n *\n * @param {Object} ast - Gonzales PE abstract syntax tree\n *\n * @returns {Object} The toggledRules object containing all of our rule enable/disable information\n */\nmodule.exports.getToggledRules = function (ast) {\n  var toggledRules = {\n    ruleEnable: {\n      // Format in here is [isEnabled, line, column]\n    },\n    globalEnable: []\n  };\n  if (!ast.traverseByTypes) {\n    return toggledRules;\n  }\n  ast.traverseByTypes(['multilineComment', 'singlelineComment'], function (comment, i, parent) {\n    var content = comment.content;\n    if (!content) {\n      return;\n    }\n    var tokens = content.split(/[\\s,]+/)\n      .filter(function (s) {\n        return s.trim().length > 0;\n      });\n    if (!tokens.length) {\n      return;\n    }\n    var first = tokens[0],\n        rules = tokens.slice(1);\n    switch (first) {\n    case 'sass-lint:disable':\n      addDisable(toggledRules, rules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:enable':\n      addEnable(toggledRules, rules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:disable-block':\n      // future ref: not sure what the appropriate behavior is if there is no parent block; currently NPEs\n      addDisableBlock(toggledRules, rules, parent);\n      break;\n    case 'sass-lint:disable-all':\n      addDisableAll(toggledRules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:enable-all':\n      addEnableAll(toggledRules, comment.start.line, comment.start.column);\n      break;\n    case 'sass-lint:disable-line':\n      addDisableLine(toggledRules, rules, comment.start.line);\n      break;\n    default:\n      return;\n    }\n  });\n  // Sort these toggle stacks so reading them is easier (algorithmically).\n  // Usually already sorted but since it's not guaranteed by the contract with gonzales-pe, ensuring it is.\n  toggledRules.globalEnable.sort(sortRange);\n  Object.keys(toggledRules.ruleEnable).map(function (ruleId) {\n    toggledRules.ruleEnable[ruleId].sort(sortRange);\n  });\n  return toggledRules;\n};\n\n/**\n * Filters our rule results by checking the lint result and its line/column against our\n * toggledRules object to see whether we should still be reporting this lint.\n *\n * @param {Object} toggledRules - The toggledRules object containing all of our rule enable/disable information\n *\n * @returns {Boolean} Whether the current rule is disabled for this lint report\n */\nmodule.exports.isResultEnabled = function (toggledRules) {\n  return function (ruleResult) {\n    var ruleId = ruleResult.ruleId;\n    // Convention: if no column or line, assume rule is targetting 1.\n    var line = ruleResult.line || 1;\n    var column = ruleResult.column || 1;\n    var isGloballyEnabled = toggledRules.globalEnable\n      .reduce(function (acc, toggleRange) {\n        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])\n          ? acc\n          : toggleRange[0];\n      }, true);\n    if (!isGloballyEnabled) {\n      return false;\n    }\n    if (!toggledRules.ruleEnable[ruleId]) {\n      return true;\n    }\n    var isRuleEnabled = toggledRules.ruleEnable[ruleId]\n      .reduce(function (acc, toggleRange) {\n        return isBeforeOrSame(line, column, toggleRange[1], toggleRange[2])\n          ? acc\n          : toggleRange[0];\n      }, true);\n    if (!isRuleEnabled) {\n      return false;\n    }\n    return true;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/bin/sass-lint.js":"#!/usr/bin/env node\n'use strict';\n\nvar program = require('commander'),\n    meta = require('../package.json'),\n    lint = require('../index');\n\nvar configPath,\n    config,\n    configOptions = {},\n    exitCode = 0;\n\nvar tooManyWarnings = function (detects, userConfig) {\n  var warningCount = lint.warningCount(detects).count;\n\n  return warningCount > 0 && warningCount > userConfig.options['max-warnings'];\n};\n\nvar detectPattern = function (pattern, userConfig) {\n  var detects = lint.lintFiles(pattern, configOptions, configPath);\n\n  if (program.verbose) {\n    lint.outputResults(detects, configOptions, configPath);\n  }\n\n  if (lint.errorCount(detects).count || tooManyWarnings(detects, userConfig)) {\n    exitCode = 1;\n  }\n\n  if (program.exit) {\n    lint.failOnError(detects, configOptions, configPath);\n  }\n};\n\nprogram\n  .version(meta.version)\n  .usage('[options] <pattern>')\n  .option('-c, --config [path]', 'path to custom config file')\n  .option('-i, --ignore [pattern]', 'pattern to ignore. For multiple ignores, separate each pattern by `, ` within a string')\n  .option('-q, --no-exit', 'do not exit on errors')\n  .option('-v, --verbose', 'verbose output')\n  .option('-f, --format [format]', 'pass one of the available eslint formats')\n  .option('-o, --output [output]', 'the path and filename where you would like output to be written')\n  .option('-s, --syntax [syntax]', 'syntax to evaluate the file(s) with (either sass or scss)')\n  .option('--max-warnings [integer]', 'Number of warnings to trigger nonzero exit code')\n  .parse(process.argv);\n\nconfigOptions.files = configOptions.files || {};\nconfigOptions.options = configOptions.options || {};\n\nif (program.config && program.config !== true) {\n  configPath = program.config;\n}\n\nif (program.ignore && program.ignore !== true) {\n  configOptions.files.ignore = program.ignore.split(', ');\n}\n\nif (program.syntax && ['sass', 'scss'].indexOf(program.syntax) > -1) {\n  configOptions.syntax = program.syntax;\n}\n\nif (program.format && program.format !== true) {\n  configOptions.options.formatter = program.format;\n}\n\nif (program.output && program.output !== true) {\n  configOptions.options['output-file'] = program.output;\n}\n\nif (program.maxWarnings && program.maxWarnings !== true) {\n  configOptions.options['max-warnings'] = program.maxWarnings;\n}\n\n// load our config here so we only load it once for each file\nconfig = lint.getConfig(configOptions, configPath);\n\nif (program.args.length === 0) {\n  detectPattern(null, config);\n}\nelse {\n  program.args.forEach(function (path) {\n    detectPattern(path, config);\n  });\n}\n\nprocess.on('exit', function () {\n  process.exit(exitCode); // eslint-disable-line no-process-exit\n});\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/extends-before-mixins.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'extends-before-mixins',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('block', function (block) {\n      var lastMixin = null;\n\n      block.forEach(function (item, j) {\n        if (item.is('include') || item.is('extend')) {\n          if (item.contains('atkeyword')) {\n            var atkeyword = item.first('atkeyword');\n\n            if (atkeyword.contains('ident')) {\n              var ident = atkeyword.first('ident');\n\n              if (ident.content === 'extend') {\n                if (j > lastMixin && lastMixin !== null) {\n                  result = helpers.addUnique(result, {\n                    'ruleId': parser.rule.name,\n                    'line': item.start.line,\n                    'column': item.start.column,\n                    'message': 'Extends should come before mixins',\n                    'severity': parser.severity\n                  });\n                }\n              }\n            }\n          }\n        }\n\n        if (item.is('include')) {\n          lastMixin = j;\n        }\n      });\n\n      lastMixin = null;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/extends-before-declarations.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'extends-before-declarations',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [],\n        error;\n\n    ast.traverseByType('block', function (block) {\n      var lastDeclaration = null;\n\n      block.forEach(function (item, j) {\n        if (item.is('include') || item.is('extend')) {\n          if (item.contains('atkeyword')) {\n            var atkeyword = item.first('atkeyword');\n\n            if (atkeyword.contains('ident')) {\n              var ident = atkeyword.first('ident');\n\n              if (ident.content === 'extend') {\n                if (j > lastDeclaration && lastDeclaration !== null) {\n                  error = {\n                    'ruleId': parser.rule.name,\n                    'line': item.start.line,\n                    'column': item.start.column,\n                    'message': 'Extends should come before declarations',\n                    'severity': parser.severity\n                  };\n                  result = helpers.addUnique(result, error);\n                }\n              }\n            }\n          }\n        }\n\n        if (item.is('declaration')) {\n          lastDeclaration = j;\n        }\n      });\n      lastDeclaration = null;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/placeholder-in-extend.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'placeholder-in-extend',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('atkeyword', function (keyword, i, parent) {\n      keyword.forEach(function (item) {\n        if (item.content === 'extend') {\n\n          parent.forEach('selector', function (selector) {\n            var placeholder = false;\n\n            selector.content.forEach(function (selectorPiece) {\n              if (selectorPiece.type === 'placeholder') {\n                placeholder = true;\n              }\n            });\n\n            if (!placeholder) {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': selector.start.line,\n                'column': selector.start.column,\n                'message': '@extend must be used with a %placeholder',\n                'severity': parser.severity\n              });\n            }\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/mixins-before-declarations.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'mixins-before-declarations',\n  'defaults': {\n    'exclude': [\n      'breakpoint',\n      'mq'\n    ]\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        error;\n\n    ast.traverseByType('include', function (node, i, parent) {\n      var depth = 0,\n          declarationCount = [depth];\n\n      parent.forEach(function (item) {\n        if (item.is('ruleset')) {\n          depth++;\n          declarationCount[depth] = 0;\n        }\n        else if (item.is('declaration')) {\n          if (item.first().is('property')) {\n            var prop = item.first();\n\n            if (prop.first().is('ident')) {\n              declarationCount[depth]++;\n            }\n          }\n        }\n        else if (item.is('include')) {\n          item.forEach('ident', function (name) {\n            if (parser.options.exclude.indexOf(name.content) === -1 && declarationCount[depth] > 0) {\n              error = {\n                'ruleId': parser.rule.name,\n                'line': item.start.line,\n                'column': item.start.column,\n                'message': 'Mixins should come before declarations',\n                'severity': parser.severity\n              };\n              result = helpers.addUnique(result, error);\n            }\n          });\n        }\n      });\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/one-declaration-per-line.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'one-declaration-per-line',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [],\n        lastLine = {};\n\n    ast.traverseByType('declaration', function (declaration, i, parent) {\n\n      if (declaration.start.line === lastLine.start || declaration.start.line === lastLine.end) {\n        if (parent.type !== 'arguments') {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': declaration.start.line,\n            'column': declaration.start.column,\n            'message': 'Only one declaration allowed per line',\n            'severity': parser.severity\n          });\n        }\n      }\n\n      lastLine.start = declaration.start.line;\n      lastLine.end = declaration.end.line;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/empty-line-between-blocks.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar counter,\n    syntax;\n\nvar findNearestReturnSCSS = function (parent, i) {\n  var previous,\n      doublePrevious,\n      space;\n\n  if (parent.content[i - 1]) {\n    previous = parent.content[i - 1];\n\n    if (i >= 2) {\n      doublePrevious = parent.content[i - 2];\n\n      // First check to see that the previous line is not a new line as if it is\n      // we don't want to recursively run the function again\n\n      if (!helpers.isEmptyLine(previous.content)) {\n        if (doublePrevious.type.indexOf('Comment') !== -1) {\n          return findNearestReturnSCSS(parent, i - 1);\n        }\n      }\n    }\n\n    if (i >= 1) {\n      if (previous.type.indexOf('Comment') !== -1) {\n        return findNearestReturnSCSS(parent, i - 1);\n      }\n\n      if (previous.type === 'space') {\n        space = helpers.isEmptyLine(previous.content);\n\n        // If there's not a new line and it's the first within the block, ignore\n        if (!space && (i - 1 === 0)) {\n          return false;\n        }\n\n        return {\n          'space': space,\n          'previous': previous\n        };\n      }\n    }\n  }\n  return false;\n};\n\nvar findNearestReturnSass = function (parent, i) {\n  var previous;\n\n  if (parent.content[i - 1]) {\n    previous = parent.content[i - 1];\n\n    if (counter === 2) {\n      return {\n        space: true,\n        previous: previous\n      };\n    }\n\n    if (previous.is('space') || previous.is('declarationDelimiter')) {\n      if (helpers.hasEOL(previous.content)) {\n        counter++;\n      }\n\n      return findNearestReturnSass(parent, i - 1);\n    }\n\n    // If ruleset, we must reset the parent to be the previous node and\n    // loop through that\n    else if (previous.is('ruleset') || previous.is('include')) {\n      var previousNode = previous.content[previous.content.length - 1];\n\n      // Set the i parameter for findNearestReturn to be the length of the\n      // content array in order to get the last one\n      return findNearestReturnSass(previousNode, previousNode.content.length);\n    }\n    else {\n      counter = 0;\n\n      if (previous.type.indexOf('Comment') !== -1) {\n\n        // If it's the first line\n        if (previous.start.line === 1) {\n          return {\n            space: true,\n            previous: previous\n          };\n        }\n\n        return findNearestReturnSass(parent, i - 1);\n      }\n    }\n  }\n\n  return {\n    space: false,\n    previous: previous\n  };\n};\n\nmodule.exports = {\n  'name': 'empty-line-between-blocks',\n  'defaults': {\n    'include': true,\n    'allow-single-line-rulesets': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n    syntax = ast.syntax;\n\n    ast.traverseByType('ruleset', function (node, j, p) {\n      var space;\n\n      if ((node.start.line === node.end.line) && parser.options['allow-single-line-rulesets']) {\n        return false;\n      }\n\n      if (syntax === 'scss') {\n        space = findNearestReturnSCSS(p, j);\n\n        if (space) {\n          if (parser.options.include && !space.space && j !== 1) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': space.previous.end.line,\n              'column': 1,\n              'message': 'Space expected between blocks',\n              'severity': parser.severity\n            });\n          }\n          else if (!parser.options.include && space.space) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': space.previous.end.line,\n              'column': 1,\n              'message': 'Space not allowed between blocks',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n      else if (syntax === 'sass') {\n        // Reset the counter for each ruleset\n        counter = 0;\n\n        if (node.is('ruleset')) {\n\n          node.forEach('block', function (block, i, parent) {\n            var previous;\n\n            // Capture the previous node\n            if (parent.content[i - 1]) {\n              previous = parent.content[i - 1];\n            }\n            else {\n              // Else set the block to act as the previous node\n              previous = block;\n            }\n\n            // If it's a new line, lets go back up to the selector\n            if (previous.is('space') && helpers.hasEOL(previous.content)) {\n              space = findNearestReturnSass(p, j);\n            }\n          });\n        }\n\n        if (space && space.previous) {\n          if (space.previous.start.line !== 1) {\n            if (parser.options.include && !space.space) {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': space.previous.end.line + 1,\n                'column': 1,\n                'message': 'Space expected between blocks',\n                'severity': parser.severity\n              });\n            }\n            else if (!parser.options.include && space.space) {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': space.previous.end.line + 1,\n                'column': 1,\n                'message': 'Space not allowed between blocks',\n                'severity': parser.severity\n              });\n            }\n          }\n        }\n      }\n      return true;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/single-line-per-selector.js":"'use strict';\n\nvar helpers = require('../helpers');\n\n/**\n * Checks a ruleset for selectors or EOL characters. If a selector is found before an EOL\n * then it returns the selector node for reporting or returns false\n *\n * @param {Object} ruleset - The ruleset node\n * @param {number} index - The current index of the delimiter\n * @returns {Object|boolean} Either the selector node or false\n */\nvar checkLineForSelector = function (ruleset, index) {\n  var curIndex = index += 1;\n  if (ruleset.content[curIndex]) {\n    for (; curIndex < ruleset.content.length; curIndex++) {\n      var curType = ruleset.content[curIndex].type;\n      if (curType === 'space' && helpers.hasEOL(ruleset.content[curIndex])) {\n        return false;\n      }\n      if (curType === 'selector' || curType === 'typeSelector') {\n        return ruleset.content[curIndex];\n      }\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = {\n  'name': 'single-line-per-selector',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('ruleset', function (ruleset) {\n      ruleset.forEach('delimiter', function (delimiter, j) {\n        var next = checkLineForSelector(ruleset, j);\n\n        if (next) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': next.start.line,\n            'column': next.start.column,\n            'message': 'Selectors must be placed on new lines',\n            'severity': parser.severity\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-color-keywords.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path');\n\nvar cssColors = yaml.safeLoad(fs.readFileSync(path.join(__dirname, '../../data', 'literals.yml'), 'utf8')).split(' ');\n\n/**\n * Checks if a node's parent is a valid type as we dont want to apply\n * this rule to function names or variable names\n *\n * @param {Object} node - The parent node to test\n * @returns {boolean} Whether the node is a valid type or not\n */\nvar checkValidParentType = function (node) {\n  if (node) {\n    return node.type === 'function' || node.type === 'variable';\n  }\n\n  return false;\n};\n\nmodule.exports = {\n  'name': 'no-color-keywords',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('value', function (node) {\n      node.traverse(function (elem, i, parent) {\n        if (elem.type === 'ident' && !checkValidParentType(parent)) {\n          var index = cssColors.indexOf(elem.content.toLowerCase());\n\n          if (index !== -1) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': elem.start.line,\n              'column': elem.start.column,\n              'message': 'Color \\'' + elem.content + '\\' should be written in its hexadecimal form #' + cssColors[index + 1],\n              'severity': parser.severity\n            });\n          }\n        }\n      });\n\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-color-literals.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path');\n\nvar colorFunctions = ['rgb', 'rgba', 'hsl', 'hsla'],\n    cssColors = yaml.safeLoad(fs.readFileSync(path.join(__dirname, '../../data', 'literals.yml'), 'utf8')).split(' ');\n\n/**\n * Returns a copy of the colour functions array\n *\n * @param {Array} colorFunctionsArr - The color functions array we wish to clone\n * @returns {Array} A copy of the color functions array.\n */\nvar getColorFunctionsCopy = function (colorFunctionsArr) {\n  return colorFunctionsArr.slice();\n};\n\n/**\n * Checks if the next node along is an operator of type ':'\n *\n * @param {Object} parent - The parent node\n * @param {number} i - The current child position in the parent node\n * @returns {boolean} If the sibling node is the correct type of operator\n */\nvar checkNextIsOperator = function (parent, i) {\n  var next = parent.content[i + 1] && parent.content[i + 1].type === 'operator' && parent.content[i + 1].content === ':';\n  var spacedNext = parent.content[i + 2] && parent.content[i + 2].type === 'operator' && parent.content[i + 2].content === ':';\n\n  return next || spacedNext;\n};\n\n/**\n * Check nested function arguments for colors/idents or further nested functions\n *\n * @param {Object} node - The node we're checking\n * @returns {boolean} Whether the node matches the specified types\n */\nvar checkForNestedFuncArgs = function (node) {\n  return node.type === 'color' || node.type === 'ident' || node.type === 'function';\n};\n\n/**\n * Check if the value is a color literal\n *\n * @param {Object} node - The node we're checking\n * @param {Array} validColorFunctions - The array of valid color function types to check against\n * @returns {boolean} Whether the node matches the specified types\n */\nvar checkIsLiteral = function (node, validColorFunctions) {\n  return cssColors.indexOf(node.content) !== -1 || helpers.isValidHex(node.content) || validColorFunctions.indexOf(node.content) !== -1;\n};\n\n/**\n * Checks the see if the node type is a hex value if so return the correct prefix\n *\n * @param {String} nodeType - The node type identifier\n * @returns {String} Either a '#' or an empty string\n */\nvar checkHexPrefix = function (nodeType) {\n  return nodeType === 'color' ? '#' : '';\n};\n\nmodule.exports = {\n  'name': 'no-color-literals',\n  'defaults': {\n    'allow-map-identifiers': true,\n    'allow-rgba': false,\n    'allow-variable-identifiers': true\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        validColorFunctions = getColorFunctionsCopy(colorFunctions);\n\n    if (parser.options['allow-rgba'] && validColorFunctions.indexOf('rgba') !== -1) {\n      validColorFunctions.splice(validColorFunctions.indexOf('rgba'), 1);\n    }\n\n    ast.traverseByTypes(['value', 'variable'], function (node, i, parent) {\n\n      // If we don't literals as variable names then check each variable name\n      if (node.is('variable') && !parser.options['allow-variable-identifiers']) {\n        if (cssColors.indexOf(node.content[0].content) !== -1) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': 'Color literals should not be used as variable names',\n            'severity': parser.severity\n          });\n        }\n      }\n      // check the value nodes\n      else if (node.is('value')) {\n        node.forEach(function (valElem) {\n          var declarationType = parent.content[0].content[0].type;\n          // check type is color, content isn't a css color literal\n          if (valElem.type === 'color' || cssColors.indexOf(valElem.content) !== -1) {\n            if (declarationType === 'ident') {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': valElem.start.line,\n                'column': valElem.start.column,\n                'message': 'Color literals such as \\'' + checkHexPrefix(valElem.type) + valElem.content + '\\' should only be used in variable declarations',\n                'severity': parser.severity\n              });\n            }\n          }\n\n          // if not a color value or a variable then check if it's a function\n          else if (valElem.type === 'function') {\n            var funcType = valElem.content[0].content;\n\n            // check it's not a blacklisted color function and even if it is that it's not assigned to a variable\n            if (validColorFunctions.indexOf(funcType) !== -1 && declarationType !== 'variable') {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': valElem.start.line,\n                'column': valElem.start.column,\n                'message': 'Color functions such as \\'' + funcType + '\\' should only be used in variable declarations',\n                'severity': parser.severity\n              });\n            }\n\n            // if rgba usage is allowed we need to make sure only variables are being passed to it.\n            else if (\n              parser.options['allow-rgba'] &&\n              funcType === 'rgba' &&\n              valElem.content[1].content[0].type !== 'variable' &&\n              declarationType !== 'variable'\n            ) {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': valElem.start.line,\n                'column': valElem.start.column,\n                'message': 'A color in variable form must be passed to rgba, literals are restricted',\n                'severity': parser.severity\n              });\n            }\n\n            // if a non color function we should check its arguments\n            else {\n              valElem.content.forEach( function (funcContent) {\n                if (funcContent.type === 'arguments') {\n                  funcContent.forEach(function (funcArgs) {\n                    // if the arguments are not functions themselves\n                    if (funcArgs.type !== 'function') {\n                      // check if the argument types are therefore color literals\n                      if ((funcArgs.type === 'color' || funcArgs.type === 'ident') && (cssColors.indexOf(funcArgs.content) !== -1 || helpers.isValidHex(funcArgs.content))) {\n                        result = helpers.addUnique(result, {\n                          'ruleId': parser.rule.name,\n                          'line': funcArgs.start.line,\n                          'column': funcArgs.start.column,\n                          'message': 'Color literals such as \\'' + checkHexPrefix(funcArgs.type) + funcArgs.content + '\\' should not be passed to functions, use variables',\n                          'severity': parser.severity\n                        });\n                      }\n                    }\n\n                    // if the argument is a function itself\n                    else {\n                      // loop its arguments\n                      funcArgs.forEach( function (nestedFuncArgs) {\n                        // check again for color literals or blacklisted color functions\n                        if (\n                          checkForNestedFuncArgs(nestedFuncArgs) &&\n                          checkIsLiteral(nestedFuncArgs, validColorFunctions)\n                        ) {\n                          result = helpers.addUnique(result, {\n                            'ruleId': parser.rule.name,\n                            'line': nestedFuncArgs.start.line,\n                            'column': nestedFuncArgs.start.column,\n                            'message': 'Color functions such as \\'' + nestedFuncArgs.content + '\\' should not be passed to functions, use variables',\n                            'severity': parser.severity\n                          });\n                        }\n                      });\n                    }\n                  });\n                }\n              });\n            }\n          }\n\n          // if not allowing literals as map identifiers check to see if the property names\n          // are the same as color literals - this is bad\n          else if (valElem.type === 'parentheses' && !parser.options['allow-map-identifiers']) {\n            valElem.traverse(function (mapVals, idx, mapValsParent) {\n              // check if the parent is a variable to allow variables named after CSS colors, e.g. `$black`\n              if (\n                mapVals.type === 'ident' &&\n                checkNextIsOperator(mapValsParent, idx) &&\n                cssColors.indexOf(mapVals.content) !== -1\n              ) {\n                result = helpers.addUnique(result, {\n                  'ruleId': parser.rule.name,\n                  'line': mapVals.start.line,\n                  'column': mapVals.start.column,\n                  'message': 'Color literals should not be used as map identifiers',\n                  'severity': parser.severity\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-css-comments.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-css-comments',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('multilineComment', function (node) {\n      if (node.content.charAt(0) !== '!') {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': node.start.line,\n          'column': node.start.column,\n          'message': 'Multiline style comments should not be used',\n          'severity': parser.severity\n        });\n      }\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-debug.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-debug',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('atkeyword', function (keyword) {\n      keyword.traverse(function (item) {\n        if (item.content === 'debug') {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': item.start.line,\n            'column': item.start.column,\n            'message': '@debug not allowed',\n            'severity': parser.severity\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-duplicate-properties.js":"'use strict';\n\nvar helpers = require('../helpers');\nvar selectorHelpers = require('../selector-helpers');\n\nmodule.exports = {\n  'name': 'no-duplicate-properties',\n  'defaults': {\n    'exclude': []\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('block', function (block) {\n      var properties = [],\n          items = [],\n          warnMessage = false;\n\n      block.eachFor('declaration', function (declaration) {\n        items.push(declaration);\n      });\n\n      items.reverse();\n\n      items.forEach(function (declaration) {\n        warnMessage = false;\n\n        declaration.eachFor('property', function (item) {\n          var property = '';\n\n          // Check if declaration is actually a variable declaration\n          if (item.content[0] && item.content[0].is('variable')) {\n            return;\n          }\n\n          item.forEach(function (subItem) {\n            // Although not a selector the method here helps us construct the proper property name\n            // taking into account any interpolation etc\n            property += selectorHelpers.constructSelector(subItem);\n          });\n\n          if (properties.indexOf(property) !== -1 && properties.length >= 1) {\n            if (parser.options.exclude.indexOf(property) !== -1 && properties[properties.length - 1] !== property) {\n              warnMessage = 'Excluded duplicate properties must directly follow each other.';\n            }\n            else if (parser.options.exclude.indexOf(property) === -1) {\n              warnMessage = 'Duplicate properties are not allowed within a block';\n            }\n          }\n\n          properties.push(property);\n\n          if (warnMessage) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': item.start.line,\n              'column': item.start.column,\n              'message': warnMessage,\n              'severity': parser.severity\n            });\n          }\n        });\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/selector-helpers.js":"'use strict';\n\n// ==============================================================================\n//  Helpers\n// ==============================================================================\n\nvar simpleIdents = [\n  'ident',\n  'number',\n  'operator',\n  'combinator',\n  'string',\n  'parentSelector',\n  'delimiter',\n  'typeSelector',\n  'attributeMatch'\n];\n\nvar subSelectors = [\n  'parentSelectorExtension',\n  'attributeName',\n  'attributeValue',\n  'dimension',\n  'selector',\n  'function'\n];\n\n/**\n * Adds grammar around our content blocks to construct selectors with\n * more readable formats.\n *\n * @param {object} val - The current value node\n * @param {string} prefix - The grammar to prefix the value with\n * @param {string} suffix - The grammar to add after the value\n * @returns {string} The correct readable format\n */\nvar addGrammar = function (val, prefix, suffix) {\n  return prefix + val.content + suffix;\n};\n\n/**\n * Adds grammar around our content blocks to construct selectors with\n * more readable formats and loops the content as they're within sub blocks.\n *\n * @param {object} val - The current value node\n * @param {string} prefix - The grammar to prefix the value with\n * @param {string} suffix - The grammar to add after the value\n * @param {function} constructSelector - The callback we wish to use which means constructSelector in this instance\n * @returns {string} The correct readable format\n */\nvar constructSubSelector = function (val, prefix, suffix, constructSelector) {\n  var content = prefix;\n  val.forEach(function (subItem) {\n    content += constructSelector(subItem);\n  });\n\n  return content + suffix;\n};\n\n// ==============================================================================\n//  Public Methods\n// ==============================================================================\n\n/**\n * Constructs a syntax complete selector for our selector matching and warning output\n *\n * @param {object} val - The current node / part of our selector\n * @returns {string} - Content: The current node with correct syntax e.g. class my-class = '.my-class'\n */\nvar constructSelector = function (val) {\n  var content = null;\n\n  if (val.is('arguments')) {\n    content = constructSubSelector(val, '(', ')', constructSelector);\n  }\n\n  else if (val.is('atkeyword')) {\n    content = constructSubSelector(val, '@', '', constructSelector);\n  }\n\n  else if (val.is('attributeSelector')) {\n    content = constructSubSelector(val, '[', ']', constructSelector);\n  }\n\n  else if (val.is('class')) {\n    content = addGrammar(val, '.', '');\n  }\n\n  else if (val.is('id')) {\n    content = addGrammar(val, '#', '');\n  }\n\n  else if (val.is('interpolation')) {\n    content = constructSubSelector(val, '#{', '}', constructSelector);\n  }\n\n  else if (val.is('nth')) {\n    content = addGrammar(val, '(', ')');\n  }\n\n  else if (val.is('nthSelector')) {\n    content = constructSubSelector(val, ':', '', constructSelector);\n  }\n\n  else if (val.is('parentheses')) {\n    content = constructSubSelector(val, '(', ')', constructSelector);\n  }\n\n  else if (val.is('placeholder')) {\n    content = constructSubSelector(val, '%', '', constructSelector);\n  }\n\n  else if (val.is('pseudoClass')) {\n    content = constructSubSelector(val, ':', '', constructSelector);\n  }\n\n  else if (val.is('pseudoElement')) {\n    content = addGrammar(val, '::', '');\n  }\n\n  else if (val.is('space')) {\n    content = ' ';\n  }\n\n  else if (val.is('variable')) {\n    content = constructSubSelector(val, '$', '', constructSelector);\n  }\n\n  else if (simpleIdents.indexOf(val.type) !== -1) {\n    content = val.content;\n  }\n\n  else if (subSelectors.indexOf(val.type) !== -1) {\n    content = constructSubSelector(val, '', '', constructSelector);\n  }\n\n  return content;\n};\n\nmodule.exports = {\n  constructSelector: constructSelector\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-empty-rulesets.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-empty-rulesets',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('block', function (block) {\n      var nonSpaceCount = 0,\n          empty = false;\n\n      if (block.content.length === 0) {\n        empty = true;\n      }\n      else {\n        block.traverse(function (item) {\n          if (!helpers.isEqual(block, item)) {\n            if (item.type !== 'space') {\n              nonSpaceCount++;\n            }\n          }\n        });\n        if (nonSpaceCount === 0) {\n          empty = true;\n        }\n      }\n\n      if (empty) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'severity': parser.severity,\n          'line': block.start.line,\n          'column': block.start.column,\n          'message': 'No empty blocks allowed'\n        });\n      }\n    });\n\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-ids.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-ids',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('id', function (id) {\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': id.start.line,\n        'column': id.start.column,\n        'message': 'ID selectors not allowed',\n        'severity': parser.severity\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-important.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-important',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('important', function (item) {\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': item.start.line,\n        'column': item.start.column,\n        'message': '!important not allowed',\n        'severity': parser.severity\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-invalid-hex.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-invalid-hex',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('color', function (value) {\n      if (!helpers.isValidHex(value.content)) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': value.start.line,\n          'column': value.start.column,\n          'message': 'Hexadecimal values must be a valid format',\n          'severity': parser.severity\n        });\n      }\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-mergeable-selectors.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    selectorHelpers = require('../selector-helpers');\n\nvar mergeableNodes = ['atrule', 'include', 'ruleset'],\n    validAtRules = ['media'],\n    curLevel = 0,\n    curSelector = [],\n    parentSelector = [],\n    selectorList = [],\n    syntax = '';\n\n\n/**\n * Traverses a block and calls our callback function for each block encountered\n *\n * @param {object} block - The current node / part of our selector\n * @param {object} cb - The callback function we wish to apply to each block\n * @returns {undefined}\n */\nvar traverseBlock = function (block, cb) {\n  block.forEach(function (contentItem) {\n    cb(contentItem);\n  });\n};\n\n/**\n * Traverses a block and calls our callback function for each block encountered\n *\n * @param {string} ruleSet - The current selector\n * @param {boolean} isAtRule - Whether the ruleSet is an atRule\n * @param {string} line - The line that the ruleset starts\n * @param {string} col - The column that the ruleset starts\n * @returns {undefined}\n */\nvar updateList = function (ruleSet, isAtRule, line, col) {\n  parentSelector[curLevel] = ruleSet;\n  curSelector = {\n    selector: helpers.stripLastSpace(parentSelector.join('')),\n    line: line,\n    column: col\n  };\n  if (!isAtRule) {\n    selectorList.push(curSelector);\n  }\n};\n\n/**\n * Checks a rulesets contents for selectors and calls our consstructSelector method\n *\n * @param {object} ruleNode - The current node / part of our selector\n * @returns {undefined}\n */\nvar checkRuleset = function (ruleNode) {\n  var ruleSet = '';\n  ruleNode.forEach(function (ruleNodeItem) {\n    if (!ruleNodeItem.is('block')) {\n      if (ruleNodeItem.is('selector')) {\n        ruleNodeItem.forEach(function (selectorContent) {\n          ruleSet += selectorHelpers.constructSelector(selectorContent);\n        });\n      }\n      else if (ruleNodeItem.is('delimiter') || ruleNodeItem.is('space')) {\n        ruleSet += selectorHelpers.constructSelector(ruleNodeItem);\n      }\n    }\n  });\n  if (ruleSet !== '') {\n    updateList(ruleSet, false, ruleNode.start.line, ruleNode.start.column);\n  }\n};\n\n/**\n * Checks an atRule contents for selectors and calls our consstructSelector method\n *\n * @param {object} atRule - The current node / atRule part of our selector\n * @returns {undefined}\n */\nvar checkAtRule = function (atRule) {\n  var test = '';\n  atRule.forEach(function (atRuleItem) {\n    if (!atRuleItem.is('block')) {\n      test += selectorHelpers.constructSelector(atRuleItem);\n    }\n  });\n  updateList(test, true, atRule.start.line, atRule.start.column);\n};\n\n/**\n * Checks an atRule to see if if it's part of our mergeable at rule list.\n * It also checks for Sass syntax as gonzales currently has issues with the syntax\n *\n * @param {object} node - The current node / atRule part of our selector\n * @returns {boolean} Whether this atRule should be merged or not\n */\nvar isMergeableAtRule = function (node) {\n  var isMergeable = false;\n  node.forEach(function (item) {\n    // TODO Check back when Gonzales updates to fix this\n    // Gonzales has issues with nest levels in media queries :(\n    if (item.is('atkeyword') && validAtRules.indexOf(item.first('ident').content) !== -1 && syntax !== 'sass') {\n      isMergeable = true;\n    }\n  });\n\n  return isMergeable;\n};\n\n/**\n * Checks if a node contains a block and if so calls our traverseBlock method. Also\n * handles our current level counter.\n *\n * @param {object} node - The current node / atRule part of our selector\n * @param {object} cb - The callback function we wish to pass through\n * @returns {undefined}\n */\nvar checkForBlock = function (node, cb) {\n  if (node.contains('block')) {\n    curLevel += 1;\n    node.forEach('block', function (block) {\n      traverseBlock(block.content, cb);\n    });\n    curLevel -= 1;\n    parentSelector.pop();\n  }\n};\n\n/**\n * Traverses a node and checks for rulesets and at rules and then fires off to the\n * respective method for them to be handled\n *\n * @param {object} node - The current node / atRule part of our selector\n * @returns {undefined}\n */\nvar traverseNode = function (node) {\n  if (mergeableNodes.indexOf(node.type) !== -1) {\n    if (node.is('ruleset')) {\n      checkRuleset(node);\n      checkForBlock(node, traverseNode);\n    }\n    else if (node.is('atrule')) {\n      if (isMergeableAtRule(node)) {\n        checkAtRule(node);\n        checkForBlock(node, traverseNode);\n      }\n    }\n  }\n};\n\n/**\n * Checks our selector list for mergeable selectors and reports errors where needed\n *\n * @param {object} parser - The parser object\n * @returns {array} Array of result objects\n */\nvar checkMergeable = function (parser) {\n  var result = [];\n  selectorList.forEach(function (item, index, arr) {\n    var pos = helpers.propertySearch(arr, item.selector, 'selector');\n    if (pos !== index && parser.options.whitelist.indexOf(item.selector) === -1) {\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': item.line,\n        'column': item.column,\n        'message': 'Rule `' + item.selector + '` should be merged with the rule on line ' + selectorList[pos].line,\n        'severity': parser.severity\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = {\n  'name': 'no-mergeable-selectors',\n  'defaults': {\n    'whitelist': []\n  },\n  'detect': function (ast, parser) {\n    curLevel = 0;\n    curSelector = [];\n    parentSelector = [];\n    selectorList = [];\n    syntax = ast.syntax;\n    ast.traverseByType('stylesheet', function (styleSheet) {\n      traverseBlock(styleSheet, traverseNode);\n    });\n    return checkMergeable(parser);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-misspelled-properties.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path');\n\nvar properties = yaml.safeLoad(fs.readFileSync(path.join(__dirname, '../../data', 'properties.yml'), 'utf8')).split(' ');\n\n/**\n * Combine the valid property array and the array of extras into a new array\n *\n * @param {Array} props - The list of default valid properties\n * @param {Array} extras - The user specified list of valid properties\n * @returns {Array} Combined list\n */\nvar getCombinedList = function (props, extras) {\n  return props.concat(extras);\n};\n\nmodule.exports = {\n  'name': 'no-misspelled-properties',\n  'defaults': {\n    'extra-properties': []\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('property', function (node) {\n      if (node.first().is('ident')) {\n        var curProperty = node.first().content,\n            propertyList = getCombinedList(properties, parser.options['extra-properties']);\n\n        if (curProperty.charAt(0) === '-') {\n          curProperty = helpers.stripPrefix(curProperty);\n        }\n\n        if (helpers.isPartialStringMatch(curProperty, propertyList)) {\n          return false;\n        }\n\n        if (curProperty.length > 0) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': 'Property `' + curProperty + '` appears to be spelled incorrectly',\n            'severity': parser.severity\n          });\n        }\n      }\n\n      return false;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-qualifying-elements.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-qualifying-elements',\n  'defaults': {\n    'allow-element-with-attribute': false,\n    'allow-element-with-class': false,\n    'allow-element-with-id': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('selector', function (selector) {\n      selector.forEach(function (item, i) {\n        if (item.is('attributeSelector') || item.is('class') || item.is('id')) {\n          var previous = selector.content[i - 1] || false;\n\n          if (previous && previous.is('typeSelector')) {\n            if (previous.contains('ident')) {\n              var type = null;\n\n              if (item.is('attributeSelector')) {\n                type = 'attribute';\n              }\n\n              if (item.is('class')) {\n                type = 'class';\n              }\n\n              if (item.is('id')) {\n                type = 'id';\n              }\n\n              if (type && !parser.options['allow-element-with-' + type]) {\n                result = helpers.addUnique(result, {\n                  'ruleId': parser.rule.name,\n                  'line': item.start.line,\n                  'column': item.start.column,\n                  'message': 'Qualifying elements are not allowed for ' + type + ' selectors',\n                  'severity': parser.severity\n                });\n              }\n            }\n          }\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-trailing-whitespace.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-trailing-whitespace',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n    var trailing = (/( |\\t)+\\n/);\n    var trailingCRLF = (/( |\\t)+\\r\\n/);\n\n    ast.traverseByType('space', function (space, i, parent) {\n      var content = space.content;\n      var nextIndex = i + 1;\n      var next = parent.content[nextIndex];\n\n      while (next && (next.is('space') || next.is('declarationDelimiter'))) {\n        content += next.content;\n        nextIndex++;\n        next = parent.content[nextIndex];\n      }\n\n      if (trailing.test(content) || trailingCRLF.test(content)) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'severity': parser.severity,\n          'line': space.start.line,\n          'column': space.start.column,\n          'message': 'No trailing whitespace allowed'\n        });\n      }\n    });\n\n    return result;\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-trailing-zero.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar trailingZeroRegex = /^(\\d+\\.|\\.)+(\\d*?)0+$/;\n\nmodule.exports = {\n  'name': 'no-trailing-zero',\n  'defaults': {\n    'include': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('number', function (num) {\n\n      if (num.content.match(trailingZeroRegex)) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': num.start.line,\n          'column': num.start.column,\n          'message': 'Don\\'t include trailing zeros on numbers',\n          'severity': parser.severity\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-transition-all.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-transition-all',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('declaration', function (declaration) {\n\n      if (declaration.first('property')) {\n        if (declaration.first('property').first('ident')) {\n          var propertyName = declaration.first('property').first('ident').content;\n\n          if (propertyName.charAt(0) === '-') {\n            propertyName = helpers.stripPrefix(propertyName);\n          }\n\n          if (propertyName === 'transition' || propertyName === 'transition-property' ) {\n            declaration.forEach('value', function (val) {\n              val.forEach('ident', function (ident) {\n                if (ident.content === 'all') {\n                  result = helpers.addUnique(result, {\n                    'ruleId': parser.rule.name,\n                    'line': declaration.start.line,\n                    'column': declaration.start.column,\n                    'message': 'The keyword `all` should not be used with the property `' + propertyName + '`',\n                    'severity': parser.severity\n                  });\n                }\n              });\n            });\n          }\n        }\n      }\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-url-domains.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    url = require('url');\n\nmodule.exports = {\n  'name': 'no-url-domains',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('uri', function (uri) {\n      uri.traverse(function (item) {\n        if (item.is('string')) {\n          var stripped = helpers.stripQuotes(item.content),\n              parsedUrl = url.parse(stripped, false, true);\n\n          if (parsedUrl.host && parsedUrl.protocol !== 'data:') {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'severity': parser.severity,\n              'line': item.end.line,\n              'column': item.end.column,\n              'message': 'Domains in URLs are disallowed'\n            });\n          }\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-url-protocols.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar isUrlRegex = /^(https?:)?\\/\\//,\n    protocolRelativeRegex = /^(https?:)\\/\\//;\n\nmodule.exports = {\n  'name': 'no-url-protocols',\n  'defaults': {\n    'allow-protocol-relative-urls': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('uri', function (uri) {\n      uri.traverse(function (item) {\n        if (item.is('string')) {\n          var stripped = helpers.stripQuotes(item.content),\n              regexSelector = !parser.options['allow-protocol-relative-urls'] ?\n                  isUrlRegex : protocolRelativeRegex,\n              message = !parser.options['allow-protocol-relative-urls'] ?\n                  'Protocols and domains in URLs are disallowed' :\n                  'Protocols in URLS are disallowed';\n\n          if (stripped.match(regexSelector)) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'severity': parser.severity,\n              'line': item.end.line,\n              'column': item.end.column,\n              'message': message\n            });\n          }\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-vendor-prefixes.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path');\n\nvar properties = yaml.safeLoad(fs.readFileSync(path.join(__dirname, '../../data', 'properties.yml'), 'utf8')).split(' '),\n    prefixes = ['webkit', 'moz', 'ms'];\n\n/**\n * Returns a copy of the prefixes array so that it can be safely modified\n *\n * @param {Array} prefixArr - The array of prefixes\n * @returns {Array} A copy of the prefixes array\n */\nvar getPrefixCopy = function (prefixArr) {\n  return prefixArr.slice();\n};\n\n/**\n * Removes specified vendor prefixes from the prefixes array\n *\n * @param {Array} prefixArr - The array of prefixes\n * @param {Array} excludes - An array of prefixes to exclude\n * @returns {Array} The prefixes array minus any excluded prefixes\n */\nvar handleExcludes = function (prefixArr, excludes) {\n  excludes.forEach(function (item) {\n    var index = prefixArr.indexOf(item);\n\n    if (index > -1) {\n      prefixArr.splice(index, 1);\n    }\n  });\n\n  return prefixArr;\n};\n\n/**\n * Adds specified vendor prefixes to the prefixes array\n *\n * @param {Array} prefixArr - The array of prefixes\n * @param {Array} includes - An array of prefixes to include\n * @returns {Array} The prefixes array plus any extra included prefixes\n */\nvar handleIncludes = function (prefixArr, includes) {\n  includes.forEach(function (item) {\n    if (prefixArr.indexOf(item) === -1) {\n      prefixArr.push(item);\n    }\n  });\n\n  return prefixArr;\n};\n\n/**\n * Creates and returns a regex pattern based on all the included prefixes so that\n * we can test our values against it.\n *\n * @param {Array} prefixArr - The array of prefixes\n * @param {Array} includes - An array of prefixes to include\n * @param {Array} excludes - An array of prefixes to exclude\n * @returns {RegExp} The regex pattern for us to test values against\n */\nvar precompileRegEx = function (prefixArr, includes, excludes) {\n  if (includes.length) {\n    prefixArr = handleIncludes(prefixArr, includes);\n  }\n\n  if (excludes.length) {\n    prefixArr = handleExcludes(prefixArr, excludes);\n  }\n\n  return new RegExp('-(' + prefixArr.join('|') + ')-');\n};\n\n/**\n * Checks to see if the property is a standard property or a browser specific one\n *\n * @param {string} property - The property string we want to test\n * @returns {boolean} Whether the property is standard or not\n */\nvar isStandardProperty = function (property) {\n  return properties.indexOf(helpers.stripPrefix(property)) !== -1;\n};\n\nmodule.exports = {\n  'name': 'no-vendor-prefixes',\n  'defaults': {\n    'additional-identifiers': [],\n    'excluded-identifiers': [],\n    'ignore-non-standard': false\n  },\n  'detect': function (ast, parser) {\n\n    var result = [],\n        validPrefixes = getPrefixCopy(prefixes),\n        statement = precompileRegEx(validPrefixes, parser.options['additional-identifiers'], parser.options['excluded-identifiers']);\n\n    ast.traverseByType('ident', function (value) {\n      if (statement.test(value.content)) {\n        if (!isStandardProperty(value.content) && parser.options['ignore-non-standard']) {\n          return;\n        }\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': value.start.line,\n          'column': value.start.column,\n          'message': 'Vendor prefixes should not be used',\n          'severity': parser.severity\n        });\n      }\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-warn.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-warn',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('atkeyword', function (keyword) {\n      keyword.traverse(function (item) {\n        if (item.content === 'warn') {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': item.start.line,\n            'column': item.start.column,\n            'message': '@warn not allowed',\n            'severity': parser.severity\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/declarations-before-nesting.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'declarations-before-nesting',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [],\n        error;\n\n    ast.traverseByType('block', function (block) {\n      if (block.contains('ruleset') && block.contains('declaration')) {\n        var rulesetIndex;\n\n        block.forEach(function (item, j) {\n          var declarationIndex;\n          var declaration;\n\n          if (item.is('ruleset') && rulesetIndex === void 0) {\n            rulesetIndex = j;\n          }\n\n          if (item.is('declaration')) {\n            var property = item.content[0];\n\n            if (property && property.is('property')) {\n              if (property.content[0] && property.content[0].is('variable')) {\n                return;\n              }\n            }\n\n            declarationIndex = j;\n            declaration = item;\n          }\n\n          if (rulesetIndex < declarationIndex && declaration) {\n            error = {\n              'ruleId': parser.rule.name,\n              'line': declaration.start.line,\n              'column': declaration.start.column,\n              'message': 'Declarations should come before nestings',\n              'severity': parser.severity\n            };\n            result = helpers.addUnique(result, error);\n          }\n        });\n\n        rulesetIndex = null;\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/force-attribute-nesting.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    capitalize = require('lodash.capitalize'),\n    kebabcase = require('lodash.kebabcase');\n\n// Our nestable selector types, separated by type for ease of use with rules\n// we replace ident with 'selector' for readability'\nvar nestableElements = ['selector', 'class', 'id', 'typeSelector', 'parentSelectorExtension'],\n    nestableAttributes = ['attributeSelector'],\n    nestablePseudo = ['pseudoClass', 'pseudoElement', 'nth', 'nthSelector'];\n\n/**\n * Formats a string from camelCase to hyphens and capitalizes\n * @param {string} str - The string to be formatted\n * @returns {string} A hyphenated and capitalized string\n */\nvar formatOutput = function (str) {\n  return capitalize(kebabcase(str));\n};\n\nmodule.exports = {\n  'name': 'force-attribute-nesting',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [],\n        elements = nestableElements.concat(nestableAttributes, nestablePseudo);\n\n    ast.traverseByType('ruleset', function (ruleset) {\n\n      ruleset.forEach('selector', function (selector) {\n        var previousVal;\n        selector.forEach(function (item) {\n          if (previousVal) {\n            if (helpers.isNestable(item.type, previousVal.type, elements, nestableAttributes)) {\n              helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': selector.start.line,\n                'column': selector.start.column,\n                'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),\n                'severity': parser.severity\n              });\n            }\n          }\n          previousVal = item;\n        });\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/force-element-nesting.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    capitalize = require('lodash.capitalize'),\n    kebabcase = require('lodash.kebabcase');\n\n// Our nestable selector types, separated by type for ease of use with rules\n// we replace ident with 'selector' for readability'\nvar nestableElements = ['selector', 'class', 'id', 'typeSelector', 'parentSelectorExtension'],\n    nestableAttributes = ['attributeSelector'],\n    nestablePseudo = ['pseudoClass', 'pseudoElement', 'nth', 'nthSelector'];\n\n/**\n * Formats a string from camelCase to hyphens and capitalizes\n * @param {string} str - The string to be formatted\n * @returns {string} A hyphenated and capitalized string\n */\nvar formatOutput = function (str) {\n  return capitalize(kebabcase(str));\n};\n\nmodule.exports = {\n  'name': 'force-element-nesting',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [],\n        elements = nestableElements.concat(nestableAttributes, nestablePseudo);\n\n    ast.traverseByType('ruleset', function (ruleset) {\n      ruleset.forEach(function (selector) {\n\n        var previousVal;\n        selector.forEach(function (item) {\n          if (previousVal) {\n            if (helpers.isNestable(item.type, previousVal.type, elements, nestableElements)) {\n              helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': selector.start.line,\n                'column': selector.start.column,\n                'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),\n                'severity': parser.severity\n              });\n            }\n          }\n          if (!item.is('space')) {\n            previousVal = item;\n          }\n        });\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/force-pseudo-nesting.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    capitalize = require('lodash.capitalize'),\n    kebabcase = require('lodash.kebabcase');\n\n// Our nestable selector types, separated by type for ease of use with rules\n// we replace ident with 'selector' for readability'\nvar nestableElements = ['selector', 'class', 'id', 'typeSelector', 'parentSelectorExtension'],\n    nestableAttributes = ['attributeSelector'],\n    nestablePseudo = ['pseudoClass', 'pseudoElement', 'nth', 'nthSelector'];\n\n/**\n * Formats a string from camelCase to hyphens and capitalizes when not\n * nth related\n * @param {string} str - The string to be formatted\n * @returns {string} A hyphenated (and possibly capitalized) string\n */\nvar formatOutput = function (str) {\n  str = kebabcase(str);\n\n  if (str.indexOf('nth') === -1) {\n    str = capitalize(str);\n  }\n\n  return str;\n};\n\nmodule.exports = {\n  'name': 'force-pseudo-nesting',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [],\n        elements = nestableElements.concat(nestableAttributes, nestablePseudo);\n\n    ast.traverseByType('ruleset', function (ruleset) {\n\n      ruleset.forEach('selector', function (selector) {\n        var previousVal;\n        selector.forEach(function (item) {\n          if (previousVal) {\n            if (helpers.isNestable(item.type, previousVal.type, elements, nestablePseudo)) {\n              helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'line': selector.start.line,\n                'column': selector.start.column,\n                'message': formatOutput(item.type) + ' should be nested within its parent ' + formatOutput(previousVal.type),\n                'severity': parser.severity\n              });\n            }\n          }\n          previousVal = item;\n        });\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/class-name-format.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'class-name-format',\n  'defaults': {\n    'allow-leading-underscore': true,\n    'convention': 'hyphenatedlowercase',\n    'convention-explanation': false,\n    'ignore': []\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('ruleset', function (ruleset) {\n      var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, 'class');\n\n      selectorAndExtensions.forEach(function (node) {\n        var name = node.content,\n            strippedName,\n            violationMessage = false;\n\n        if (parser.options.ignore.indexOf(name) !== -1) {\n          return;\n        }\n\n        strippedName = name;\n\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\n          strippedName = name.slice(1);\n        }\n\n        switch (parser.options.convention) {\n        case 'hyphenatedlowercase':\n          if (!helpers.isHyphenatedLowercase(strippedName)) {\n            violationMessage = 'Class \\'.' + name + '\\' should be written in lowercase with hyphens';\n          }\n          break;\n        case 'camelcase':\n          if (!helpers.isCamelCase(strippedName)) {\n            violationMessage = 'Class \\'.' + name + '\\' should be written in camelCase';\n          }\n          break;\n        case 'pascalcase':\n          if (!helpers.isPascalCase(strippedName)) {\n            violationMessage = 'Class \\'.' + name + '\\' should be written in PascalCase';\n          }\n          break;\n        case 'snakecase':\n          if (!helpers.isSnakeCase(strippedName)) {\n            violationMessage = 'Class \\'.' + name + '\\' should be written in snake_case';\n          }\n          break;\n        case 'strictbem':\n          if (!helpers.isStrictBEM(strippedName)) {\n            violationMessage = 'Class \\'.' + name + '\\' should be written in BEM (Block Element Modifier) format';\n          }\n          break;\n        case 'hyphenatedbem':\n          if (!helpers.isHyphenatedBEM(strippedName)) {\n            violationMessage = 'Class \\'.' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\n          }\n          break;\n        default:\n          if (!(new RegExp(parser.options.convention).test(strippedName))) {\n            violationMessage = 'Class \\'.' + name + '\\' should match regular expression /' + parser.options.convention + '/';\n\n            // convention-message overrides violationMessage\n            if (parser.options['convention-explanation']) {\n              violationMessage = parser.options['convention-explanation'];\n            }\n          }\n        }\n\n        if (violationMessage) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': violationMessage,\n            'severity': parser.severity\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/function-name-format.js":"// Note that this file is nearly identical to mixin-name-format.js, placeholder-name-format.js, and variable-name-format.js\n'use strict';\n\nvar helpers = require('../helpers'),\n    yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path');\n\nvar whitelist = yaml.safeLoad(fs.readFileSync(path.join(__dirname, '../../data', 'functions.yml'), 'utf8')).split(' ');\n\nmodule.exports = {\n  'name': 'function-name-format',\n  'defaults': {\n    'allow-leading-underscore': true,\n    'convention': 'hyphenatedlowercase',\n    'convention-explanation': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('function', function (node) {\n      var name = node.first('ident').content,\n          strippedName,\n          violationMessage = false;\n\n      // ignore functions on whitelist - css3 transforms\n      if (whitelist.indexOf(name) !== -1) {\n        return;\n      }\n\n      strippedName = name;\n\n      if (parser.options['allow-leading-underscore'] && name[0] === '_') {\n        strippedName = name.slice(1);\n      }\n\n      switch (parser.options.convention) {\n      case 'hyphenatedlowercase':\n        if (!helpers.isHyphenatedLowercase(strippedName)) {\n          violationMessage = 'Function \\'' + name + '\\' should be written in lowercase with hyphens';\n        }\n        break;\n      case 'camelcase':\n        if (!helpers.isCamelCase(strippedName)) {\n          violationMessage = 'Function \\'' + name + '\\' should be written in camelCase';\n        }\n        break;\n      case 'pascalcase':\n        if (!helpers.isPascalCase(strippedName)) {\n          violationMessage = 'Function \\'' + name + '\\' should be written in PascalCase';\n        }\n        break;\n      case 'snakecase':\n        if (!helpers.isSnakeCase(strippedName)) {\n          violationMessage = 'Function \\'' + name + '\\' should be written in snake_case';\n        }\n        break;\n      case 'strictbem':\n        if (!helpers.isStrictBEM(strippedName)) {\n          violationMessage = 'Function \\'' + name + '\\' should be written in BEM (Block Element Modifier) format';\n        }\n        break;\n      case 'hyphenatedbem':\n        if (!helpers.isHyphenatedBEM(strippedName)) {\n          violationMessage = 'Function \\'' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\n        }\n        break;\n      default:\n        if (!(new RegExp(parser.options.convention).test(strippedName))) {\n          violationMessage = 'Function \\'' + name + '\\' should match regular expression /' + parser.options.convention + '/';\n\n          // convention-message overrides violationMessage\n          if (parser.options['convention-explanation']) {\n            violationMessage = parser.options['convention-explanation'];\n          }\n        }\n      }\n\n      if (violationMessage) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': node.start.line,\n          'column': node.start.column,\n          'message': violationMessage,\n          'severity': parser.severity\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/mixin-name-format.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'mixin-name-format',\n  'defaults': {\n    'allow-leading-underscore': true,\n    'convention': 'hyphenatedlowercase',\n    'convention-explanation': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['mixin', 'include'], function (node) {\n      var name,\n          strippedName,\n          violationMessage = false;\n\n      if (node.is('mixin')) {\n        if (node.contains('ident')) {\n          name = node.first('ident').content;\n        }\n      }\n      else {\n        // We're not linting extends here\n        if (node.contains('atkeyword')) {\n          if (node.first('atkeyword').contains('ident')) {\n            if (node.first('atkeyword').first('ident').content === 'extend') {\n              return false;\n            }\n          }\n        }\n\n        if (node.contains('ident')) {\n          name = node.first('ident').content;\n        }\n      }\n\n      if (name) {\n        strippedName = name;\n\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\n          strippedName = name.slice(1);\n        }\n\n        switch (parser.options.convention) {\n        case 'hyphenatedlowercase':\n          if (!helpers.isHyphenatedLowercase(strippedName)) {\n            violationMessage = 'Mixin \\'' + name + '\\' should be written in lowercase with hyphens';\n          }\n          break;\n        case 'camelcase':\n          if (!helpers.isCamelCase(strippedName)) {\n            violationMessage = 'Mixin \\'' + name + '\\' should be written in camelCase';\n          }\n          break;\n        case 'pascalcase':\n          if (!helpers.isPascalCase(strippedName)) {\n            violationMessage = 'Mixin \\'' + name + '\\' should be written in PascalCase';\n          }\n          break;\n        case 'snakecase':\n          if (!helpers.isSnakeCase(strippedName)) {\n            violationMessage = 'Mixin \\'' + name + '\\' should be written in snake_case';\n          }\n          break;\n        case 'strictbem':\n          if (!helpers.isStrictBEM(strippedName)) {\n            violationMessage = 'Mixin \\'' + name + '\\' should be written in BEM (Block Element Modifier) format';\n          }\n          break;\n        case 'hyphenatedbem':\n          if (!helpers.isHyphenatedBEM(strippedName)) {\n            violationMessage = 'Mixin \\'' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\n          }\n          break;\n        default:\n          if (!(new RegExp(parser.options.convention).test(strippedName))) {\n            violationMessage = 'Mixin \\'' + name + '\\' should match regular expression /' + parser.options.convention + '/';\n\n            // convention-message overrides violationMessage\n            if (parser.options['convention-explanation']) {\n              violationMessage = parser.options['convention-explanation'];\n            }\n          }\n        }\n\n        if (violationMessage) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': violationMessage,\n            'severity': parser.severity\n          });\n        }\n      }\n      return true;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/placeholder-name-format.js":"// Note that this file is nearly identical to function-name-format.js, mixin-name-format.js, and variable-name-format.js\n'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'placeholder-name-format',\n  'defaults': {\n    'allow-leading-underscore': true,\n    'convention': 'hyphenatedlowercase',\n    'convention-explanation': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('placeholder', function (node) {\n      var name = node.first().content,\n          strippedName,\n          violationMessage = false;\n\n      if (node.first().is('ident')) {\n        strippedName = name;\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\n          strippedName = name.slice(1);\n        }\n\n        switch (parser.options.convention) {\n        case 'hyphenatedlowercase':\n          if (!helpers.isHyphenatedLowercase(strippedName)) {\n            violationMessage = 'Placeholder \\'%' + name + '\\' should be written in lowercase with hyphens';\n          }\n          break;\n        case 'camelcase':\n          if (!helpers.isCamelCase(strippedName)) {\n            violationMessage = 'Placeholder \\'%' + name + '\\' should be written in camelCase';\n          }\n          break;\n        case 'pascalcase':\n          if (!helpers.isPascalCase(strippedName)) {\n            violationMessage = 'Placeholder \\'%' + name + '\\' should be written in PascalCase';\n          }\n          break;\n        case 'snakecase':\n          if (!helpers.isSnakeCase(strippedName)) {\n            violationMessage = 'Placeholder \\'%' + name + '\\' should be written in snake_case';\n          }\n          break;\n        case 'strictbem':\n          if (!helpers.isStrictBEM(strippedName)) {\n            violationMessage = 'Placeholder \\'%' + name + '\\' should be written in BEM (Block Element Modifier) format';\n          }\n          break;\n        case 'hyphenatedbem':\n          if (!helpers.isHyphenatedBEM(strippedName)) {\n            violationMessage = 'Placeholder \\'%' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\n          }\n          break;\n        default:\n          if (!(new RegExp(parser.options.convention).test(strippedName))) {\n            violationMessage = 'Placeholder \\'%' + name + '\\' should match regular expression /' + parser.options.convention + '/';\n\n            // convention-message overrides violationMessage\n            if (parser.options['convention-explanation']) {\n              violationMessage = parser.options['convention-explanation'];\n            }\n          }\n        }\n\n        if (violationMessage) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': violationMessage,\n            'severity': parser.severity\n          });\n        }\n      }\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/variable-name-format.js":"// Note that this file is nearly identical to function-name-format.js, mixin-name-format.js, and placeholder-name-format.js\n'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'variable-name-format',\n  'defaults': {\n    'allow-leading-underscore': true,\n    'convention': 'hyphenatedlowercase',\n    'convention-explanation': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('variable', function (variable) {\n      var strippedName,\n          violationMessage = false,\n          name = variable.first().content;\n\n\n      strippedName = name;\n\n      if (parser.options['allow-leading-underscore'] && name[0] === '_') {\n        strippedName = strippedName.slice(1);\n      }\n\n      switch (parser.options.convention) {\n      case 'hyphenatedlowercase':\n        if (!helpers.isHyphenatedLowercase(strippedName)) {\n          violationMessage = 'Variable \\'' + name + '\\' should be written in lowercase with hyphens';\n        }\n        break;\n      case 'camelcase':\n        if (!helpers.isCamelCase(strippedName)) {\n          violationMessage = 'Variable \\'' + name + '\\' should be written in camelCase';\n        }\n        break;\n      case 'pascalcase':\n        if (!helpers.isPascalCase(strippedName)) {\n          violationMessage = 'Variable \\'' + name + '\\' should be written in PascalCase';\n        }\n        break;\n      case 'snakecase':\n        if (!helpers.isSnakeCase(strippedName)) {\n          violationMessage = 'Variable \\'' + name + '\\' should be written in snake_case';\n        }\n        break;\n      case 'strictbem':\n        if (!helpers.isStrictBEM(strippedName)) {\n          violationMessage = 'Variable \\'' + name + '\\' should be written in BEM (Block Element Modifier) format';\n        }\n        break;\n      case 'hyphenatedbem':\n        if (!helpers.isHyphenatedBEM(strippedName)) {\n          violationMessage = 'Variable \\'' + name + '\\' should be written in hyphenated BEM (Block Element Modifier) format';\n        }\n        break;\n      default:\n        if (!(new RegExp(parser.options.convention).test(strippedName))) {\n          violationMessage = 'Variable \\'' + name + '\\' should match regular expression /' + parser.options.convention + '/';\n\n          // convention-message overrides violationMessage\n          if (parser.options['convention-explanation']) {\n            violationMessage = parser.options['convention-explanation'];\n          }\n        }\n      }\n\n      if (violationMessage) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': variable.start.line,\n          'column': variable.start.column,\n          'message': violationMessage,\n          'severity': parser.severity\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/attribute-quotes.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'attribute-quotes',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('attributeValue', function (item) {\n      if (item.content[0].is('string') && !parser.options.include) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': item.start.line,\n          'column': item.start.column,\n          'message': 'Attribute values should not be surrounded by quotes',\n          'severity': parser.severity\n        });\n      }\n      else if (item.content[0].is('ident') && parser.options.include) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': item.start.line,\n          'column': item.start.column,\n          'message': 'Attribute values should be surrounded by quotes',\n          'severity': parser.severity\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/border-zero.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar borders = ['border', 'border-top', 'border-right', 'border-bottom', 'border-left'];\nvar allowedConventions = ['0', 'none'];\n\nmodule.exports = {\n  'name': 'border-zero',\n  'defaults': {\n    'convention': '0'\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n    var userConvention = parser.options.convention.toString();\n    var convention = allowedConventions.indexOf(userConvention) !== -1\n      ? userConvention\n      : allowedConventions[0];\n    var invalidConvention = convention !== userConvention;\n\n    ast.traverseByType('declaration', function (declaration) {\n      var isBorder = false;\n\n      declaration.traverse(function (item) {\n        if (item.type === 'property') {\n          item.traverse(function (child) {\n            if (borders.indexOf(child.content) !== -1) {\n              isBorder = true;\n            }\n          });\n        }\n\n        if (isBorder) {\n          if (item.type === 'value') {\n            var node = item.content[0];\n            if (node.type === 'number' || node.type === 'ident') {\n              if (node.content === '0' || node.content === 'none') {\n                if (convention !== node.content) {\n                  if (invalidConvention) {\n                    invalidConvention = false;\n                    result = helpers.addUnique(result, {\n                      'ruleId': parser.rule.name,\n                      'line': 1,\n                      'column': 1,\n                      'message': 'The border-zero convention `' + userConvention + ' in your config file is not valid. Defaulted to convention \\'0\\'',\n                      'severity': parser.severity\n                    });\n                  }\n                  result = helpers.addUnique(result, {\n                    'ruleId': parser.rule.name,\n                    'line': node.start.line,\n                    'column': node.start.column,\n                    'message': 'A value of `' + node.content + '` is not allowed. `' + convention + '` must be used.',\n                    'severity': parser.severity\n                  });\n                }\n              }\n            }\n          }\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/brace-style.js":"'use strict';\n\nvar helpers = require('../helpers');\n\n/**\n * Get the current block within a node\n *\n * @param {Object} node - The node containing our desired block\n * @returns {Object} The current block of the node\n */\nvar getCurrentNode = function (node) {\n  return node.contains('block') ? node.first('block') : false;\n};\n\n/**\n * Get the previous node\n *\n * @param {Object} node - Our current node\n * @returns {Object|bool} The previous node or false if not found\n */\nvar getPreviousNode = function (node) {\n  // Rulesets\n  if (node.is('ruleset')) {\n    return node.contains('selector') ? node.last('selector') : false;\n  }\n\n  // Conditonal statements\n  if (node.is('conditionalStatement')) {\n    var previousParent = node.contains('condition') ? node.last('condition') : false;\n    return previousParent && previousParent.contains('atkeyword') ? previousParent.last('atkeyword') : false;\n  }\n\n  // Loops\n  if (node.is('loop')) {\n    return node.contains('atkeyword') ? node.last('atkeyword') : false;\n  }\n\n  // Mixins and atrules (functions etc)\n  if (node.is('mixin') || node.is('atrule')) {\n    if (node.contains('function')) {\n      return node.last('function');\n    }\n\n    if (node.contains('arguments')) {\n      return node.last('arguments');\n    }\n    return node.contains('atkeyword') ? node.last('atkeyword') : false;\n  }\n\n  return false;\n};\n\n/**\n * Determine if current node is an exception and end checks if it is\n * If we've picked up a return @rule ignore it\n *\n * @param {Object} node - The original node\n * @param {object} currentNode - The current node block\n * @param {Object} previousNode - The node previous to our current node\n * @returns {bool} Whether or not the it is an exception\n */\nvar isException = function (node, currentNode, previousNode) {\n  if (node.is('atrule')) {\n    if (previousNode.contains('ident') && previousNode.first('ident').content === 'return') {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Determine if statement is a single line statement\n *\n * @param {Object} node - The statement to check\n * @returns {bool} True or false\n */\nvar isSingleLineStatement = function (node) {\n  return node.start.line === node.end.line;\n};\n\n/**\n * Determine if opening brace of statement is on a new line\n *\n * @param {Object} nodeA - The previous block\n * @param {Object} nodeB - The current block\n * @returns {bool} True or false\n */\nvar isOpeningBraceOnNewLine = function (nodeA, nodeB) {\n  return nodeA.end.line === nodeB.start.line;\n};\n\n/**\n * Determine if closing brace of statement is on new line\n *\n * @param {Object} node - The current block\n * @returns {bool|null} True or false if relevant else null\n */\nvar isClosingBraceOnNewLine = function (node) {\n  if (node.contains('block')) {\n    var content = node.first('block'),\n        contentLength = content.length - 1,\n        lastNode = content.get(contentLength);\n\n    if (lastNode && lastNode.is('space') && helpers.hasEOL(lastNode.content)) {\n      return true;\n    }\n    return false;\n  }\n  return null;\n};\n\n/**\n * Determine if condition starts on a new line by checking the leading node for\n * an end-of-line\n *\n * @param {Object} node - The node that is our condition\n * @param {Object} parentNode - The condition node's parent\n * @param {Number} j - The index of our node in the context of the parent's children\n * @returns {bool|null} True or false if relevant else null\n */\nvar isConditionOnNewLine = function (node, parentNode, j) {\n  var currentNode = node;\n\n  // Check node is part of an `else if` and if it is, use the else node instead\n  if (node.first('ident').content === 'if') {\n    var initialNode = parentNode.get(j);\n    currentNode = initialNode.contains('atkeyword') ? initialNode.first('atkeyword') : false;\n  }\n\n  // Only check if it's an @else condition\n  if (currentNode && currentNode.contains('ident') && currentNode.first('ident').content === 'else') {\n    // Reverse back up tree\n    var previousChild = parentNode.get(--j) || false;\n    if (previousChild) {\n      // Determine if we have a leading new line\n      if (previousChild.is('space') && helpers.hasEOL(previousChild.content)) {\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n  return null;\n};\n\n/**\n * Run the rule checks and return their results\n *\n * @param {Object} node - The original node\n * @param {Object} currentNode - The current node block\n * @param {Object} previousNode - The node previous to our current node\n * @param {Object} parentNode - The parent of the original node\n * @param {int} index - The index of the original node\n * @returns {Object} The results of the rule checks\n */\nvar runRuleChecks = function (node, currentNode, previousNode, parentNode, index) {\n  var checks = {};\n\n  // Determine if single line statement\n  checks.singleLineStatement = isSingleLineStatement(node);\n\n  // Determine if condition is on a new line\n  if (node.is('atrule') || node.is('conditionalStatement')) {\n    checks.conditionOnNewLine = isConditionOnNewLine(previousNode, parentNode, index);\n  }\n\n  // Determine if opening brace is on new line\n  if (previousNode && currentNode) {\n    checks.openingBraceOnNewLine = isOpeningBraceOnNewLine(previousNode, currentNode);\n  }\n\n  // Determine if closing brace is on new line\n  checks.closingBraceOnNewLine = isClosingBraceOnNewLine(node);\n\n  return checks;\n};\n\n/**\n * Filter at-rules\n *\n * @param {Object} node - The node to filter\n * @param {Array} accepted - The array of accepted at-rule types\n * @returns {bool} true if we should ignore, false to continue\n */\nvar filterAtrule = function (node, accepted) {\n  if (node.is('atrule')) {\n    if (node.contains('atkeyword') && node.first('atkeyword').contains('ident')) {\n      if (accepted.indexOf(node.first('atkeyword').first('ident').content) === -1) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Create an issue using the supplied information\n *\n * @param {Object} parser - The parser\n * @param {Object} node - The node with the issue\n * @param {string} message - The message to display\n * @returns {Object} An object containing an issue\n */\nvar createIssue = function (parser, node, message) {\n  return {\n    'ruleId': parser.rule.name,\n    'line': node.line,\n    'column': node.column,\n    'message': message,\n    'severity': parser.severity\n  };\n};\n\nmodule.exports = {\n  'name': 'brace-style',\n  'defaults': {\n    'style': '1tbs',\n    'allow-single-line': true\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        acceptedAtrules = [\n          'function',\n          'if',\n          'else'\n        ];\n\n    ast.traverseByTypes(['conditionalStatement', 'atrule', 'ruleset', 'mixin', 'loop'], function (node, i, parent) {\n      var currentNode = false,\n          previousNode = false,\n          checks = {\n            singleLineStatement: null,\n            openingBraceOnNewLine: null,\n            closingBraceOnNewLine: null,\n            conditionOnNewLine: null\n          },\n          messages = [\n            'Single line statements are not allowed',\n            'Opening brace must be on the same line as condition',\n            'Brace must be on a new line',\n            'Statement must start on the same line as the closing brace of the previous statement',\n            'Statement must begin on a new line',\n            'Closing brace must be on a new line'\n          ];\n\n      // SCSS syntax only rule\n      if (ast.syntax === 'sass') {\n        return false;\n      }\n\n      // Filter at-rule types\n      if (filterAtrule(node, acceptedAtrules)) {\n        return false;\n      }\n\n      // Assign current & previous nodes based on node type\n      currentNode = getCurrentNode(node);\n      previousNode = getPreviousNode(node);\n\n      // If not an exception carry on\n      if (!isException(node, currentNode, previousNode)) {\n\n        // Run and store rule check results\n        checks = runRuleChecks(node, currentNode, previousNode, parent, i);\n\n        // Build single-line statement results\n        if (checks.singleLineStatement === false && checks.closingBraceOnNewLine === false) {\n          result = helpers.addUnique(result, createIssue(parser, {\n            line: currentNode.end.line,\n            column: currentNode.end.column\n          }, messages[5]));\n        }\n\n        if (checks.singleLineStatement === true) {\n          if (parser.options['allow-single-line'] === false) {\n            result = helpers.addUnique(result, createIssue(parser, {\n              line: node.start.line,\n              column: node.start.column\n            }, messages[0]));\n          }\n          return false;\n        }\n\n        // Build brace-style results\n        if (previousNode && currentNode) {\n          if (parser.options.style === '1tbs') {\n            if (checks.openingBraceOnNewLine === false) {\n              result = helpers.addUnique(result, createIssue(parser, {\n                line: currentNode.start.line,\n                column: currentNode.start.column\n              }, messages[1]));\n            }\n            if (checks.conditionOnNewLine === true) {\n              result = helpers.addUnique(result, createIssue(parser, {\n                line: previousNode.start.line,\n                column: previousNode.start.column\n              }, messages[3]));\n            }\n          }\n\n          if (parser.options.style === 'stroustrup') {\n            if (checks.openingBraceOnNewLine === false) {\n              result = helpers.addUnique(result, createIssue(parser, {\n                line: currentNode.start.line,\n                column: currentNode.start.column\n              }, messages[1]));\n            }\n            if (checks.conditionOnNewLine === false) {\n              result = helpers.addUnique(result, createIssue(parser, {\n                line: previousNode.start.line,\n                column: previousNode.start.column\n              }, messages[4]));\n            }\n          }\n\n          if (parser.options.style === 'allman') {\n            if (checks.openingBraceOnNewLine === true) {\n              result = helpers.addUnique(result, createIssue(parser, {\n                line: currentNode.end.line,\n                column: currentNode.end.column\n              }, messages[2]));\n            }\n            if (checks.conditionOnNewLine === false) {\n              result = helpers.addUnique(result, createIssue(parser, {\n                line: previousNode.start.line,\n                column: previousNode.start.column\n              }, messages[4]));\n            }\n          }\n        }\n      }\n\n      return true;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/clean-import-paths.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    path = require('path');\n\nvar getImportPath = function (parent, syntax) {\n  if (parent.first('uri')) {\n    return parent.first('uri');\n  }\n\n  if (parent.first('string')) {\n    return helpers.stripQuotes(parent.first('string').content);\n  }\n\n  if (parent.first('ident')) {\n\n    if (syntax === 'sass') {\n      var output = '',\n          isFinished = false;\n\n      parent.forEach(function (item) {\n        // Force an end if we've appended a 'class'.. aka file extension\n        if (!isFinished) {\n          // Since we don't have quotes, gonzales-pe will parse file path as\n          // multiple different types\n          if (\n            item.type === 'string'\n            || item.type === 'operator'\n            || item.type === 'ident'\n          ) {\n            output += item.content;\n          }\n\n          // Gonzales-pe parses file extensions as classes if they are not\n          // wrapped in quotes...\n          if (item.type === 'class') {\n            if (item.first('ident')) {\n              output += '.' + item.first('ident').content;\n            }\n\n            isFinished = true;\n          }\n        }\n      });\n\n      return output.trim();\n    }\n\n    return parent.first('ident');\n  }\n\n  return false;\n};\n\nmodule.exports = {\n  'name': 'clean-import-paths',\n  'defaults': {\n    'leading-underscore': false,\n    'filename-extension': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('atkeyword', function (keyword, i, parent) {\n      keyword.forEach(function (item) {\n        if (item.content === 'import') {\n          var importPath = getImportPath(parent, keyword.syntax);\n\n          if (importPath) {\n            if (typeof importPath === 'string') {\n              var filename = path.basename(importPath),\n                  fileExtension = path.extname(filename);\n\n              if (fileExtension === '.sass' || fileExtension === '.scss' || fileExtension === '') {\n                if (filename.charAt(0) === '_') {\n                  if (!parser.options['leading-underscore']) {\n                    result = helpers.addUnique(result, {\n                      'ruleId': parser.rule.name,\n                      'line': item.start.line,\n                      'column': item.start.column,\n                      'message': 'Leading underscores are not allowed',\n                      'severity': parser.severity\n                    });\n                  }\n                }\n                else {\n                  if (parser.options['leading-underscore']) {\n                    result = helpers.addUnique(result, {\n                      'ruleId': parser.rule.name,\n                      'line': item.start.line,\n                      'column': item.start.column,\n                      'message': 'Leading underscores are required',\n                      'severity': parser.severity\n                    });\n                  }\n                }\n\n                if (fileExtension) {\n                  if (!parser.options['filename-extension']) {\n                    result = helpers.addUnique(result, {\n                      'ruleId': parser.rule.name,\n                      'line': item.start.line,\n                      'column': item.start.column,\n                      'message': 'File extensions are not allowed',\n                      'severity': parser.severity\n                    });\n                  }\n                }\n                else {\n                  if (parser.options['filename-extension']) {\n                    result = helpers.addUnique(result, {\n                      'ruleId': parser.rule.name,\n                      'line': item.start.line,\n                      'column': item.start.column,\n                      'message': 'File extensions are required',\n                      'severity': parser.severity\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/empty-args.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'empty-args',\n  'defaults': {\n    'include': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['mixin', 'include'], function (item) {\n      if (item.contains('arguments')) {\n        item.traverse(function (node) {\n          if (node.type === 'arguments') {\n            if (node.content.length === 0) {\n              if (!parser.options.include) {\n                result = helpers.addUnique(result, {\n                  'ruleId': parser.rule.name,\n                  'line': node.start.line,\n                  'column': node.start.column,\n                  'message': 'Parenthesis should be removed.',\n                  'severity': parser.severity\n                });\n              }\n            }\n          }\n        });\n      }\n      else {\n        if (parser.options.include) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': item.start.line,\n            'column': item.start.column,\n            'message': 'Parenthesis are required.',\n            'severity': parser.severity\n          });\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/hex-length.js":"'use strict';\n\nvar helpers = require('../helpers');\nvar lengths = {\n  short: 3,\n  long: 6\n};\nvar canShorten = function (hex) {\n  return hex.length === lengths.long &&\n          hex[0] === hex[1] &&\n          hex[2] === hex[3] &&\n          hex[4] === hex[5];\n};\n\nmodule.exports = {\n  'name': 'hex-length',\n  'defaults': {\n    'style': 'short'\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('color', function (value) {\n      if (parser.options.style === 'short' && canShorten(value.content)) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': value.start.line,\n          'column': value.start.column,\n          'message': 'Hex values should use the shorthand format - 3 characters where possible',\n          'severity': parser.severity\n        });\n      }\n      else if (parser.options.style === 'long') {\n        if (value.content.length !== lengths.long) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': value.start.line,\n            'column': value.start.column,\n            'message': 'Hex values should use the long-form format - 6 characters',\n            'severity': parser.severity\n          });\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/hex-notation.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'hex-notation',\n  'defaults': {\n    'style': 'lowercase'\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('color', function (value) {\n      if (value.content.match(/[a-z]/i)) {\n        if (parser.options.style === 'lowercase') {\n          if (!helpers.isLowerCase(value.content)) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': value.start.line,\n              'column': value.start.column,\n              'message': 'Hex notation should all be lower case',\n              'severity': parser.severity\n            });\n          }\n        }\n        else if (parser.options.style === 'uppercase') {\n          if (!helpers.isUpperCase(value.content)) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': value.start.line,\n              'column': value.start.column,\n              'message': 'Hex notation should all be upper case',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/indentation.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'indentation',\n  'defaults': {\n    'size': 2\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        inAtRule = false,\n        inProps = false,\n        inBlock = false,\n        lintSize = parser.options.size,\n        lintType = 'space',\n        plural = '',\n        detected = [lintType];\n\n    // Prepare to check for mixed spaces or tabs depending on what the user has specified\n    if (parser.options.size === 'tab') {\n      lintSize = 1;\n      lintType = 'tab';\n      detected[0] = lintType;\n    }\n\n    var processNode = function (node, level) {\n      var i,\n          n,\n          prevNode,\n          nextNode,\n          sassNextNode,\n          reportNode,\n          reportCondition,\n          space,\n          spaceLength,\n          newlineLength,\n          spaceCount,\n          tabCount,\n          mixedWarning;\n\n      level = level || 0;\n\n      if (node.is('braces')) {\n        return;\n      }\n\n      for (i = 0; i < node.length; i++) {\n        n = node.get(i);\n        prevNode = node.get(i - 1);\n        nextNode = node.get(i + 1) || false;\n        // Due to the Sass structure in gonzales we sometimes need to check 2 ahead\n        sassNextNode = node.get(i + 2) || false;\n        reportNode = null;\n\n        if (!n) {\n          continue;\n        }\n\n        if (n.syntax === 'scss') {\n          if (n.type === 'space') {\n\n            // Test for CRLF first, since it includes LF\n            space = n.content.lastIndexOf('\\r\\n');\n            newlineLength = 2;\n\n            if (space === -1) {\n              // Test for LF\n              space = n.content.lastIndexOf('\\n');\n              newlineLength = 1;\n            }\n\n            if (space >= 0) {\n              // Check how many spaces or tabs we have and set our plural character if necessary for\n              // our lint reporting message\n              spaceLength = n.content.slice(space + newlineLength).length;\n              spaceCount = n.content.slice(space + newlineLength).match(/ /g);\n              tabCount = n.content.slice(space + newlineLength).match(/\\t/g);\n              plural = level > 1 ? 's' : '';\n              reportNode = nextNode;\n              reportCondition = i !== node.length - 1;\n            }\n          }\n        }\n        else if (n.syntax === 'sass') {\n          if (n.is('declarationDelimiter') || (helpers.isNewLine(n))) {\n            // Due to the way gonzales handles line endings in Sass we don't care if it's CRLF or just LF\n            if (nextNode && nextNode.is('space') && nextNode.content.indexOf('\\n') === -1) {\n              spaceLength = nextNode.content.length;\n              spaceCount = nextNode.content.match(/ /g);\n              tabCount = nextNode.content.match(/\\t/g);\n              plural = level > 1 ? 's' : '';\n\n              // if we're at the end of a block we want to drop the level here for Sass\n              if (!node.get(i + 2)) {\n                level--;\n              }\n\n              reportNode = sassNextNode;\n              reportCondition = true;\n            }\n          }\n          // Check all the spaces in Sass that aren't newlines\n          else if (helpers.isSpace(n)) {\n            // This is a special condition for the first property in a block with Sass as it usually\n            // doesn't have a previous node before the space appears so we need to check this is\n            // valid and then we can rely on the declarationDelimiter check above.\n            if (inBlock && (!prevNode || prevNode.is('space'))) {\n              inBlock = false;\n              spaceLength = n.content.length;\n              spaceCount = n.content.match(/ /g);\n              tabCount = n.content.match(/\\t/g);\n              plural = level > 1 ? 's' : '';\n              reportNode = nextNode;\n              reportCondition = true;\n            }\n            // A extra check for tabs when using spaces as single tab characters aren't highlighted\n            // as mixed spaces and tabs without this. Spaces on the other hand are fine. Gonzales\n            // reports them a little differently.\n            else if (n.type === 'space' && lintType === 'space') {\n              tabCount = n.content.match(/\\t/g);\n              reportNode = nextNode;\n              // we dont want to check the lint levels here as it could be a tab between a prop and\n              // value, totally unrealistic I know but we still want to report it.\n              reportCondition = false;\n            }\n          }\n        }\n        if (reportNode) {\n          // if we've encountered a space check if we have before if not save a reference\n          if (spaceCount !== null && detected.indexOf('space') === -1) {\n            detected.push('space');\n          }\n\n          // if we've encountered a tab check if we have before if not save a reference\n          if (tabCount !== null && detected.indexOf('tab') === -1) {\n            detected.push('tab');\n          }\n\n          if (detected.length > 1) {\n            // Indicates we've told the user about mixed tabs and spaces in their file\n            mixedWarning = true;\n            // Remove the last detected type from our detected array,\n            // if we encounter a mix again we'll output again but all the while keep a reference\n            // to the first space character (tab or space) that we encountered so as to be\n            // consistent with our warnings\n            detected.pop();\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': reportNode.start.line,\n              'column': reportNode.start.column,\n              'message': 'Mixed tabs and spaces',\n              'severity': parser.severity\n            });\n          }\n          if (reportCondition && !mixedWarning && spaceLength / lintSize !== level) {\n            // Check if expected indentation matches what it should be\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': reportNode.start.line,\n              'column': reportNode.start.column,\n              'message': 'Expected indentation of ' + level * lintSize + ' ' + lintType + plural + ' but found ' + spaceLength + '.',\n              'severity': parser.severity\n            });\n          }\n          mixedWarning = false;\n        }\n        // if we're in an atrule make we need to possibly handle multiline arguments\n        if (n.is('atrule') && n.contains('block')) {\n          inAtRule = true;\n          inBlock = false;\n        }\n\n        // if a delimeter is encountered we check if it's directly after a parenthesis node\n        // if it is we know next node will be the same level of indentation\n        if (n.is('operator')) {\n          if (n.content === ',' && prevNode.is('parentheses') && helpers.isNewLine(nextNode)) {\n            if (inAtRule && !inProps) {\n              level++;\n              inProps = true;\n            }\n            else if (!inProps) {\n              level--;\n            }\n          }\n        }\n\n        // if a block node is encountered we first check to see if it's within an include/function\n        // by checking if the node also contains arguments, if it does we skip the block as we add a level\n        // for arguments anyway. If not the the block is a usual ruleset block and should be treated accordingly\n        // The other checks are kept from 1.0 and work for their respective types.\n        if ((n.is('block') && !node.contains('arguments'))\n          || n.is('arguments')\n          || (n.is('parentheses') && !node.is('atrule'))\n        ) {\n          level++;\n        }\n\n        if (n.is('block')) {\n          inAtRule = false;\n          inProps = false;\n          inBlock = true;\n        }\n        processNode(n, level);\n      }\n    };\n\n    processNode(ast);\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/leading-zero.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar leadingZeroRegex = /^0\\.\\d+$/,\n    noLeadingZeroRegex = /^\\.\\d+$/;\n\nmodule.exports = {\n  'name': 'leading-zero',\n  'defaults': {\n    'include': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('number', function (num) {\n      if (num.content.match(/^-?(0?\\.\\d+)/)) {\n        if (num.content.match(leadingZeroRegex)) {\n          if (!parser.options.include) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': num.start.line,\n              'column': num.start.column,\n              'message': 'Don\\'t include leading zeros on numbers',\n              'severity': parser.severity\n            });\n          }\n        }\n        if (num.content.match(noLeadingZeroRegex)) {\n          if (parser.options.include) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': num.start.line,\n              'column': num.start.column - 1,\n              'message': 'Include leading zeros on numbers',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/nesting-depth.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'nesting-depth',\n  'defaults': {\n    'max-depth': 2\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        nodes = {},\n        depth = 0;\n\n    var recursiveSearch = function (node) {\n      if (node.contains('block')) {\n        node.forEach('block', function (block) {\n          if (block.contains('ruleset')) {\n            depth++;\n            block.forEach('ruleset', function (ruleset) {\n              var selector = ruleset.first('selector');\n\n              if (depth > parser.options['max-depth']) {\n                var nodeLineColumn = selector.start.line + ':' + selector.start.column;\n\n                if (nodes[nodeLineColumn]) {\n                  if (depth > nodes[nodeLineColumn].depth) {\n                    nodes[nodeLineColumn].depth = depth;\n                  }\n                }\n                else {\n                  nodes[nodeLineColumn] = {\n                    'line': selector.start.line,\n                    'column': selector.start.column,\n                    'depth': depth\n                  };\n                }\n              }\n              else {\n                recursiveSearch(ruleset);\n              }\n            });\n          }\n        });\n      }\n      depth--;\n    };\n\n    ast.traverseByType('selector', function (selector, i, parent) {\n      recursiveSearch(parent);\n      depth = 0;\n    });\n\n    Object.keys(nodes).forEach(function (node) {\n      node = nodes[node];\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': node.line,\n        'column': node.column,\n        'message': 'Nesting depth ' + node.depth + ' greater than max of ' + parser.options['max-depth'],\n        'severity': parser.severity\n      });\n    });\n\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/property-sort-order.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path');\n\nvar propertyCheckList = yaml.safeLoad(fs.readFileSync(path.join(__dirname, '../../data', 'properties.yml'), 'utf8')).split(' ');\n\nvar orderPresets = {\n  'recess': 'recess.yml',\n  'smacss': 'smacss.yml',\n  'concentric': 'concentric.yml'\n};\n\nvar getOrderConfig = function (order) {\n  if (typeof order === 'string') {\n    if (orderPresets.hasOwnProperty(order)) {\n      var filename = orderPresets[order],\n          orderConfig = helpers.loadConfigFile('property-sort-orders/' + filename);\n\n      return orderConfig.order;\n    }\n  }\n\n  return false;\n};\n\nvar sortProperties = function (obj, order) {\n  var keys = Object.keys(obj),\n      unknown = [],\n      sorted = {},\n      i;\n\n  if (typeof order === 'string') {\n    if (order === 'alphabetical') {\n      keys = keys.sort();\n    }\n  }\n  else if (typeof order === 'object') {\n    var orderedKeys = [];\n\n    for (i = 0; i < order.length; i++) {\n      if (keys.indexOf(order[i]) !== -1) {\n        orderedKeys.push(order[i]);\n      }\n    }\n\n    keys = orderedKeys;\n  }\n  else {\n    keys = keys.sort(function (a, b) {\n      if (order.indexOf(a) === -1) {\n        if (unknown.indexOf(a) === -1) {\n          unknown.push(a);\n        }\n      }\n      if (order.indexOf(b) === -1) {\n        if (unknown.indexOf(b) === -1) {\n          unknown.push(b);\n        }\n      }\n\n      if (order.indexOf(a) > order.indexOf(b)) {\n        return 1;\n      }\n      if (order.indexOf(a) < order.indexOf(b)) {\n        return -1;\n      }\n      return 0;\n    });\n  }\n\n  for (i = 0; i < unknown.length; i++) {\n    if (keys.indexOf(unknown[i]) !== -1) {\n      keys.splice(keys.indexOf(unknown[i]), 1);\n    }\n  }\n\n  keys = keys.concat(unknown.sort());\n\n  for (i = 0; i < keys.length; i++) {\n    sorted[keys[i]] = obj[keys[i]];\n  }\n\n  return sorted;\n};\n\nmodule.exports = {\n  'name': 'property-sort-order',\n  'defaults': {\n    'order': 'alphabetical',\n    'ignore-custom-properties': false\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        order = getOrderConfig(parser.options.order) || parser.options.order;\n\n    ast.traverseByType('block', function (block) {\n      var properties = {},\n          sorted,\n          pKeys,\n          sKeys;\n\n      if (block) {\n        block.forEach('declaration', function (dec) {\n          var prop = dec.first('property'),\n              name = prop.first('ident');\n\n          if (name) {\n            if (parser.options['ignore-custom-properties']) {\n              if (propertyCheckList.indexOf(name.content) !== -1) {\n                properties[name.content] = prop;\n              }\n            }\n            else {\n              properties[name.content] = prop;\n            }\n          }\n        });\n\n        sorted = sortProperties(properties, order);\n\n        pKeys = Object.keys(properties);\n        sKeys = Object.keys(sorted);\n\n        sKeys.every(function (e, i) {\n          var pKey = pKeys[i],\n              prop = properties[pKey];\n\n          if (e !== pKey) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': prop.start.line,\n              'column': prop.start.column,\n              'message': 'Expected `' + e + '`, found `' + pKey + '`',\n              'severity': parser.severity\n            });\n          }\n          return true;\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/pseudo-element.js":"'use strict';\n\nvar helpers = require('../helpers'),\n    yaml = require('js-yaml'),\n    fs = require('fs'),\n    path = require('path');\n\nvar pseudoElements = yaml.safeLoad(\n      fs.readFileSync(path.join(__dirname, '../../data', 'pseudoElements.yml'), 'utf8')\n    ).split(' '),\n    pseudoClasses = yaml.safeLoad(\n      fs.readFileSync(path.join(__dirname, '../../data', 'pseudoClasses.yml'), 'utf8')\n    ).split(' ');\n\n/**\n * Check if the given argument is a prefixed string. If it is we return an unprefixed\n * version, else return it unmodified\n *\n * @param {Object|string} name - The value to test\n * @returns {string} A prefix free version of the string\n */\nvar prefixFree = function prefixFree (name) {\n  return typeof name === 'string' && name.charAt(0) === '-' ? helpers.stripPrefix(name) : name;\n};\n\n/**\n * Determine if the given string matches a pseudo-element\n *\n * @param {string} name - The name to check\n * @returns {Boolean} Whether or not name is pseudo-element\n */\nvar isPseudoElement = function isPseudoElement (name) {\n  return pseudoElements.indexOf(prefixFree(name)) !== -1;\n};\n\n/**\n * Determine if the given string matches a pseudo-class\n *\n * @param {string} name - The name to check\n * @returns {Boolean} Whether or not name is pseudo-class\n */\nvar isPseudoClass = function isPseudoClass (name) {\n  return pseudoClasses.indexOf(prefixFree(name)) !== -1;\n};\n\nmodule.exports = {\n  'name': 'pseudo-element',\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('pseudoClass', function (node) {\n      if (isPseudoElement(node.content[0].content)) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': node.start.line,\n          'column': node.start.column,\n          'message': 'Pseudo-elements must start with double colons',\n          'severity': parser.severity\n        });\n      }\n    });\n\n    ast.traverseByType('pseudoElement', function (node) {\n      if (isPseudoClass(node.content[0].content)) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': node.start.line,\n          'column': node.start.column,\n          'message': 'Pseudo-classes must start with a single colon',\n          'severity': parser.severity\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/quotes.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'quotes',\n  'defaults': {\n    'style': 'single'\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('string', function (node) {\n      var firstQuote = node.content.charAt(0),\n          lastQuote = node.content.charAt(node.content.length - 1);\n\n      if (firstQuote !== lastQuote) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': node.start.line,\n          'column': node.start.column,\n          'message': 'Mixed quote styles',\n          'severity': parser.severity\n        });\n      }\n\n      if (parser.options.style === 'single' && firstQuote !== '\\'') {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': node.start.line,\n          'column': node.start.column,\n          'message': 'Strings must use single quotes',\n          'severity': parser.severity\n        });\n      }\n      else if (parser.options.style === 'double' && firstQuote !== '\"') {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'line': node.start.line,\n          'column': node.start.column,\n          'message': 'Strings must use double quotes',\n          'severity': parser.severity\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/shorthand-values.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar shortVals = [\n  'border-color',\n  'border-radius',\n  'border-style',\n  'border-width',\n  'margin',\n  'padding'\n];\n\n/**\n * Checks to see if a series of values can be condensed down to a singular value\n *\n * @param {array} value - The array of values to check\n * @param {array} allowed - The parser options to specify the levels allowed to condense to\n * @returns {boolean} Whether the values can be condensed to a singular value\n */\nvar condenseToOne = function (value, allowed) {\n  if (allowed.indexOf(1) !== -1 && value.length > 1) {\n    for (var i = 1; i < value.length; i++) {\n      if (value[i] !== value[0]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * Checks to see if a series of values can be condensed down to two values\n *\n * @param {array} value - The array of values to check\n * @param {array} allowed - The parser options to specify the levels allowed to condense to\n * @returns {boolean} Whether the values can be condensed to two values\n */\nvar condenseToTwo = function (value, allowed) {\n  if (allowed.indexOf(2) !== -1 && value.length > 2) {\n    if ((value[0] === value[2] && value[1] === value[3]) || (value[0] === value[2] && !value[3] && value[0] !== value[1])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Checks to see if a series of values can be condensed down to three values\n *\n * @param {array} value - The array of values to check\n * @param {array} allowed - The parser options to specify the levels allowed to condense to\n * @returns {boolean} Whether the values can be condensed to three values\n */\nvar condenseToThree = function (value, allowed) {\n  if (allowed.indexOf(3) !== -1 && value.length > 3) {\n    if (value[1] === value[3] ) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Used to scan property values and create a string representation of the values to display\n *\n * @param {Object} node - The current node\n * @returns {string} A string reconstruction of the current properties value\n */\nvar scanValue = function (node) {\n  var curValue = [];\n  var fullVal = '';\n  node.forEach(function (val) {\n    // add to our value string depending on node type\n    if (val.is('dimension')) {\n      val.forEach(function (el) {\n        fullVal += el.content;\n      });\n    }\n\n    else if (val.is('percentage')) {\n      val.forEach(function (el) {\n        fullVal += el.content + '%';\n      });\n    }\n\n    else if (val.is('interpolation')) {\n      fullVal += '#{' + scanValue(val.content) + '}';\n    }\n\n    else if (val.is('color')) {\n      fullVal += '#' + val.content + '';\n    }\n\n    else if (\n      val.is('operator') ||\n      val.is('ident') ||\n      val.is('number') ||\n      val.is('unaryOperator') ||\n      val.is('string')\n    ) {\n      fullVal += val.content;\n    }\n\n    else if (val.is('variable')) {\n      val.forEach(function (el) {\n        fullVal += '$' + el.content;\n      });\n    }\n\n    else if (val.is('function')) {\n\n      var func = val.first('ident'),\n          args = '';\n\n      val.forEach('arguments', function (arg) {\n        args = scanValue(arg).join(' ');\n      });\n\n      fullVal = func + '(' + args + ')';\n    }\n\n    else if (val.is('parentheses')) {\n      fullVal += '(' + scanValue(val).join(' ') + ')';\n    }\n\n    else if (val.is('space')) {\n      // This is a non value character such as a space\n      // We want to start another value here\n      curValue.push(fullVal);\n\n      // reset the value string for the next iteration\n      fullVal = '';\n    }\n  });\n\n  if (fullVal !== '') {\n    // The last dimension in a value will not be followed by a character so we push here\n    curValue.push(fullVal);\n  }\n  return curValue;\n};\n\nmodule.exports = {\n  'name': 'shorthand-values',\n  'defaults': {\n    'allowed-shorthands': [1, 2, 3]\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('declaration', function (declaration) {\n      var isShorthandProperty = false,\n          property;\n\n      declaration.traverse(function (item) {\n\n        if (item.is('property')) {\n          item.traverse(function (child) {\n            // check if the property is a possible shorthand property\n            if (shortVals.indexOf(child.content) !== -1) {\n              isShorthandProperty = true;\n\n              // store a reference to the property for our error\n              property = shortVals[shortVals.indexOf(child.content)];\n            }\n          });\n        }\n\n        if (isShorthandProperty) {\n          var value = [];\n\n          if (item.is('value')) {\n            var node = item.content;\n\n            // Build each value into an array of strings with value and type\n            value = scanValue(node);\n\n            if (value.length <= 4 && value.length >= 1) {\n              var output = [];\n\n              // check which values can condense\n              if (condenseToOne(value, parser.options['allowed-shorthands'])) {\n                output = [value[0]];\n              }\n              else if (condenseToTwo(value, parser.options['allowed-shorthands'])) {\n                output = [value[0], value[1]];\n              }\n              else if (condenseToThree(value, parser.options['allowed-shorthands'])) {\n                output = [value[0], value[1], value[2]];\n              }\n\n              if (output.length) {\n                result = helpers.addUnique(result, {\n                  'ruleId': parser.rule.name,\n                  'line': item.start.line,\n                  'column': item.start.column,\n                  'message': 'Property `' + property + '` should be written more concisely as `' + output.join(' ') + '` instead of `' + value.join(' ') + '`',\n                  'severity': parser.severity\n                });\n              }\n            }\n          }\n        }\n      });\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/url-quotes.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar isVarRegex = /^[\\$]/;\n\nmodule.exports = {\n  'name': 'url-quotes',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('uri', function (node) {\n      node.traverse(function (item) {\n        if (item.is('raw')) {\n          if (!item.content.match(isVarRegex)) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'severity': parser.severity,\n              'line': item.start.line,\n              'column': item.start.column,\n              'message': 'Quotes around URLs are required'\n            });\n          }\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/variable-for-property.js":"'use strict';\n\nvar helpers = require('../helpers');\n\n// The whitelisted ident values\nvar whitelistedValues = ['inherit', 'initial', 'transparent', 'none', 'currentColor'],\n    ignoredValueTypes = ['important', 'space'];\n\n/**\n * Checks If the property is of a valid type, either its a variable or it's a whitelisted ident value\n *\n * @param {Object} propertyElem - The property element\n * @returns {boolean} Whether the property is valid or not\n */\nvar isValidProperty = function (propertyElem) {\n  if (propertyElem) {\n    if (propertyElem.type === 'variable') {\n      return true;\n    }\n    else if (propertyElem.type === 'ident' && whitelistedValues.indexOf(propertyElem.content) !== -1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Checks If the property type is an ignored value type\n *\n * @param {Object} propertyElem - The property element\n * @returns {boolean} Whether the property is an ignored type or not\n */\nvar isIgnoredType = function (propertyElem) {\n  if (propertyElem) {\n    return ignoredValueTypes.indexOf(propertyElem.type) !== -1;\n  }\n  return false;\n};\n\nmodule.exports = {\n  'name': 'variable-for-property',\n  'defaults': {\n    'properties': []\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    if (parser.options.properties.length) {\n      ast.traverseByType('value', function (node, i, parent) {\n        var declaration = parent.content[0].content[0],\n            declarationType = declaration.type,\n            declarationIdent = declaration.content;\n\n        if (declarationType === 'ident') {\n          if (parser.options.properties.indexOf(declarationIdent) !== -1) {\n            node.forEach(function (valElem) {\n              if (!isValidProperty(valElem) && !isIgnoredType(valElem)) {\n                result = helpers.addUnique(result, {\n                  'ruleId': parser.rule.name,\n                  'line': declaration.start.line,\n                  'column': declaration.start.column,\n                  'message': 'Values for properties of type \\'' + declarationIdent + '\\' may only be variables',\n                  'severity': parser.severity\n                });\n              }\n            });\n          }\n        }\n      });\n    }\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/zero-unit.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar units = [\n  'em',\n  'ex',\n  'ch',\n  'rem',\n  'vh',\n  'vw',\n  'vmin',\n  'vmax',\n  'px',\n  'mm',\n  'cm',\n  'in',\n  'pt',\n  'pc'\n];\n\nmodule.exports = {\n  'name': 'zero-unit',\n  'defaults': {\n    'include': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('number', function (item, i, parent) {\n\n      if (item.content === '0') {\n        if (parent.type === 'dimension') {\n          var next = parent.content[i + 1] || false;\n\n          if (units.indexOf(next.content) !== -1) {\n            if (!parser.options.include) {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'severity': parser.severity,\n                'line': item.end.line,\n                'column': item.end.column,\n                'message': 'No unit allowed for values of 0'\n              });\n            }\n          }\n        }\n        else {\n          if (parent.type === 'value') {\n            if (parser.options.include) {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'severity': parser.severity,\n                'line': item.end.line,\n                'column': item.end.column,\n                'message': 'Unit required for values of 0'\n              });\n            }\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-after-comma.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'space-after-comma',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['operator', 'delimiter'], function (operator, i, parent) {\n      var next,\n          doubleNext;\n\n      if (operator.content === ',') {\n        next = parent.content[i + 1] || false;\n        doubleNext = parent.content[i + 2] || false;\n\n        if (next) {\n          if (operator.is('delimiter')) {\n            if (next.is('selector')) {\n              next = next.content[0];\n            }\n          }\n\n          if ((next.is('space') && !helpers.hasEOL(next.content)) && !parser.options.include) {\n            if (doubleNext && doubleNext.is('singlelineComment')) {\n              return false;\n            }\n\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': next.start.line,\n              'column': next.start.column,\n              'message': 'Commas should not be followed by a space',\n              'severity': parser.severity\n            });\n          }\n\n          if (!next.is('space') && parser.options.include) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': operator.start.line,\n              'column': operator.start.column,\n              'message': 'Commas should be followed by a space',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n      return true;\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-before-colon.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'space-before-colon',\n  'defaults': {\n    'include': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['propertyDelimiter', 'operator'], function (delimiter, i, parent) {\n      if (delimiter.content === ':') {\n        var previous = parent.content[i - 1];\n\n        if (previous && previous.is('space')) {\n          if (!parser.options.include) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': previous.start.line,\n              'column': previous.start.column,\n              'message': 'No space allowed before `:`',\n              'severity': parser.severity\n            });\n          }\n        }\n        else {\n          if (parser.options.include) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': delimiter.start.line,\n              'column': delimiter.start.column - 1,\n              'message': 'Space expected before `:`',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-after-colon.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'space-after-colon',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['propertyDelimiter', 'operator'], function (delimiter, i, parent) {\n      if (delimiter.content === ':') {\n        var next = parent.content[i + 1];\n\n        if (next && next.is('space')) {\n          if (!parser.options.include) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': next.start.line,\n              'column': next.start.column,\n              'message': 'No space allowed after `:`',\n              'severity': parser.severity\n            });\n          }\n        }\n        else {\n          if (parser.options.include) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': delimiter.start.line,\n              'column': delimiter.start.column,\n              'message': 'Space expected after `:`',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-before-brace.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar getLastWhitespace = function (node) {\n  if (node === false) {\n    return null;\n  }\n\n  if (!node) {\n    return false;\n  }\n  if (node.is('space')) {\n    return node;\n  }\n\n  return getLastWhitespace(node.last());\n};\n\nmodule.exports = {\n  'name': 'space-before-brace',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n    if (ast.syntax === 'scss') {\n      ast.traverseByTypes(['block', 'atrulers', 'declaration'], function (block, i, parent) {\n        var previous = false,\n            whitespace,\n            warn = {};\n\n        if ((block.is('block') || block.is('atrulers')) && !parent.is('value')) {\n          previous = parent.get(i - 1);\n        }\n        else if (block.is('declaration')) {\n          if (block.contains('value')) {\n            for (var j = 0; j < block.content.length; j++) {\n              if (block.content[j].is('value') && block.content[j].content[0].is('block')) {\n                previous = block.content[j - 1];\n                warn.line = block.content[j].content[0].start.line;\n                warn.col = block.content[j].content[0].start.column;\n              }\n            }\n          }\n        }\n        whitespace = getLastWhitespace(previous);\n        if (whitespace === false) {\n          if (parser.options.include) {\n            if (!warn.hasOwnProperty('line')) {\n              warn.line = block.start.line;\n              warn.col = block.start.column;\n            }\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': warn.line,\n              'column': warn.col - 1,\n              'message': 'Whitespace required before {',\n              'severity': parser.severity\n            });\n          }\n        }\n        else {\n          if (!parser.options.include && whitespace !== null) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': whitespace.start.line,\n              'column': whitespace.start.column,\n              'message': 'Whitespace not allowed before {',\n              'severity': parser.severity\n            });\n          }\n        }\n      });\n    }\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-before-bang.js":"'use strict';\n\nvar helpers = require('../helpers.js');\n\nmodule.exports = {\n  'name': 'space-before-bang',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['important', 'default'], function (block, i, parent) {\n      var previous = parent.content[i - 1];\n\n      if (!previous.is('space')) {\n        if (parser.options.include) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': block.start.line,\n            'column': block.start.column,\n            'message': 'Whitespace required before !important',\n            'severity': parser.severity\n          });\n        }\n      }\n      else {\n        if (!parser.options.include) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': previous.start.line,\n            'column': previous.start.column,\n            'message': 'Whitespace not allowed before !important',\n            'severity': parser.severity\n          });\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-after-bang.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'space-after-bang',\n  'defaults': {\n    'include': false\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        regex = /!\\s/;\n\n    ast.traverseByTypes(['important', 'default', 'global', 'optional'], function (block) {\n      if (block.content.match(regex) !== null) {\n        if (parser.options.include) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': block.start.line,\n            'column': block.start.column + 1,\n            'message': 'Bangs (!) should be followed by a space',\n            'severity': parser.severity\n          });\n        }\n        else {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': block.start.line,\n            'column': block.start.column,\n            'message': 'Bangs (!) should not be followed by a space',\n            'severity': parser.severity\n          });\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-between-parens.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'space-between-parens',\n  'defaults': {\n    'include': false\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('arguments', function (args) {\n      var first = args.first(),\n          last = args.last();\n\n      if (args.length === 0) {\n        return;\n      }\n\n      if (parser.options.include) {\n        if (!first.is('space')) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': first.start.line,\n            'column': first.start.column - 1,\n            'message': 'Space expected at beginning of parenthesis',\n            'severity': parser.severity\n          });\n        }\n        if (!last.is('space')) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': last.end.line,\n            'column': last.end.column,\n            'message': 'Space expected at end of parenthesis',\n            'severity': parser.severity\n          });\n        }\n      }\n      else {\n        // Ignore if arguments are multi-line\n        if (first.is('space') && !helpers.hasEOL(first.content)) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': first.start.line,\n            'column': first.start.column,\n            'message': 'No space allowed at beginning of parenthesis',\n            'severity': parser.severity\n          });\n        }\n        if (last.is('space')) {\n          // Proceed if arguments aren't multi-line.\n          // With Sass we have one extra check for nested nodes where we must\n          // check doublePrevious as the last node will be the indentation\n          if (\n            (ast.syntax === 'scss' && !helpers.hasEOL(last.content))\n            || (ast.syntax === 'sass' && !helpers.hasEOL(last.content) && !helpers.hasEOL(args.content[args.content.length - 2].content))\n          ) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': last.start.line,\n              'column': last.start.column,\n              'message': 'No space allowed at end of parenthesis',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/space-around-operator.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nvar operators = ['+', '-', '/', '*', '%', '<', '>', '==', '!=', '<=', '>='];\n\n/**\n * Determine a relational operator based on the operator node\n *\n * @param {Object} node - The operator node\n * @returns {string} Returns a relational operator\n */\nvar getRelationalOperator = function (node) {\n  if (node.content === '<') {\n    return '<=';\n  }\n\n  if (node.content === '>') {\n    return '>=';\n  }\n  return false;\n};\n\n/**\n * Determine if operator is negative number\n *\n * @param {string} operator - The operator\n * @param {Object} next - The next node\n * @param {Object} previous - The previous node\n * @param {Object} doublePrevious - The double previous node (back two)\n * @returns {bool} true / false\n */\nvar isNegativeNumber = function (operator, next, previous, doublePrevious) {\n  if (operator === '-') {\n\n    // Catch the following:\n    // $foo: -20;\n    // $foo: -#{$foo}\n    // $foo: -($foo * 2)\n    // $foo: -$foo\n    if (next) {\n      if (!previous || (previous.is('space') && doublePrevious && !doublePrevious.is('number'))) {\n        if (\n          next.is('number') ||\n          next.is('interpolation') ||\n          next.is('variable') ||\n          next.is('parentheses')\n        ) {\n          return true;\n        }\n      }\n    }\n\n    // Catch the following:\n    // .foo {\n    //   property: -16px;\n    // }\n    if (next && (next.is('dimension') || next.is('percentage'))) {\n      return true;\n    }\n\n    // Catch the following:\n    // .foo {\n    //   propery: 2 / -16;\n    // }\n    if (doublePrevious && doublePrevious.is('operator')) {\n      return true;\n    }\n\n    // Catch the following:\n    // .foo {\n    //   property: 2 /-16px;\n    // }\n    if (previous && previous.is('operator')) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Determine if operator is divider\n *\n * @param {string} operator - The operator\n * @param {Object} next - The next node\n * @param {Object} previous - The previous node\n * @returns {bool} true / false\n */\nvar isDivider = function (operator, next, previous) {\n  if (operator === '/') {\n\n    // Catch the following:\n    // .foo {\n    //   property: calc(100% / 2);\n    // }\n    if (previous && next) {\n      if (previous.is('dimension') && (next.is('dimension') || next.is('number'))) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Determine if operator is part of unicode\n *\n * @param {string} operator - The operator\n * @param {Object} previous - The previous node\n * @returns {bool} true / false\n */\nvar isUnicode = function (operator, previous) {\n  if (operator === '+') {\n\n    // Catch the following:\n    // @font-face {\n    //   unicode-range: U+26;\n    // }\n    if (previous && previous.is('ident') && previous.content === 'U') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Determine if operator is part of import path\n *\n * @param {string} operator - The operator\n * @param {Object} parent - The parent node\n * @returns {bool} true / false\n */\nvar isImport = function (operator, parent) {\n  if (operator === '/') {\n\n    if (parent && parent.is('atrule') && parent.contains('atkeyword')) {\n      var keyword = parent.first('atkeyword');\n\n      if (keyword.contains('ident')) {\n        var ident = keyword.first('ident');\n\n        if (ident.content === 'import') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Determine if operator is part an ident\n *\n * @param {string} operator - The operator\n * @param {Object} next - The next node\n * @param {Object} previous - The previous node\n * @returns {bool} true / false\n */\nvar isPartialIdent = function (operator, next, previous) {\n  if (operator === '-') {\n    return next && previous && previous.is('interpolation');\n  }\n  return false;\n};\n\n/**\n * Determine if operator is exception\n *\n * @param {string} operator - The operator\n * @param {Object} parent - The parent node\n * @param {Object} i - The node index\n * @returns {bool} true / false\n */\nvar isException = function (operator, parent, i) {\n  var previous = parent.content[i - 1] || false,\n      doublePrevious = parent.content[i - 2] || false,\n      next = parent.content[i + 1] || false;\n\n  if (isNegativeNumber(operator, next, previous, doublePrevious)) {\n    return true;\n  }\n\n  if (isDivider(operator, next, previous)) {\n    return true;\n  }\n\n  if (isUnicode(operator, previous)) {\n    return true;\n  }\n\n  if (isImport(operator, parent)) {\n    return true;\n  }\n\n  if (isPartialIdent(operator, next, previous)) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Check the spacing around an operator\n *\n * @param {Object} node - The node to check the spacing around\n * @param {int} i - The node's child index of it's parent\n * @param {Object} parent - The parent node\n * @param {Object} parser - The parser object\n * @param {Object} result - The result object\n * @returns {bool|null} false if exception\n */\nvar checkSpacing = function (node, i, parent, parser, result) {\n  if (node.is('operator') || node.is('unaryOperator')) {\n    var previous = parent.content[i - 1] || false,\n        next = parent.content[i + 1] || false,\n        operator = node.content;\n\n    //////////////////////////\n    // Multi-part operators\n    //////////////////////////\n\n    // If second part of relational operator move on\n    if (node.content === '=' && previous) {\n      if (previous.content === '<' || previous.content === '>') {\n        return false;\n      }\n    }\n\n    // If first part of relational operator, carry on and build it\n    if ((node.content === '<' || node.content === '>') && next) {\n      if (next.content === '=') {\n        operator = getRelationalOperator(node);\n        next = parent.content[i + 2] || false;\n      }\n    }\n\n    //////////////////////////\n    // Exceptions\n    //////////////////////////\n\n    if (isException(operator, parent, i)) {\n      return false;\n    }\n\n    // If the operator checks out in our valid operator list\n    if (operators.indexOf(operator) !== -1) {\n\n      if (parser.options.include) {\n        if (\n          (previous && !previous.is('space'))\n          || (next && !next.is('space'))\n        ) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': 'Space expected around operator',\n            'severity': parser.severity\n          });\n        }\n        else {\n          if (\n              (previous && (previous.end.line >= previous.start.line) && (previous.end.column > previous.start.column))\n              || (next && (next.end.line >= next.start.line) && (next.end.column > next.start.column))\n            ) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': node.start.line,\n              'column': node.start.column,\n              'message': 'Multiple spaces not allowed around operator',\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n      else {\n        if (\n          (previous && previous.is('space'))\n          || (next && next.is('space'))\n        ) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': 'No spaces allowed around operator',\n            'severity': parser.severity\n          });\n        }\n      }\n    }\n  }\n  return result;\n};\n\nmodule.exports = {\n  'name': 'space-around-operator',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['condition', 'atrule', 'value'], function (node) {\n      node.forEach(function (item, i, parent) {\n        // Perform another loop of the children if we come across a parenthesis\n        // parent node\n        if (item.is('parentheses')) {\n          item.forEach(function (child, j, childParent) {\n            // Do the spacing checks\n            checkSpacing(child, j, childParent, parser, result);\n          });\n        }\n        else {\n          // Do the spacing checks\n          checkSpacing(item, i, parent, parser, result);\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/trailing-semicolon.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'trailing-semicolon',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    if (ast.syntax !== 'sass') {\n      ast.traverseByType('block', function (block) {\n        var last,\n            next;\n\n        try {\n          last = block.last('declaration');\n        }\n        catch (e) {\n          return;\n        }\n\n        block.forEach('declaration', function (item, i, parent) {\n          if (item.contains('value')) {\n            var valueNode = item.last('value').content[0];\n\n            if (!valueNode.is('block')) {\n              if (helpers.isEqual(last, item)) {\n                if (parent.content[i + 1]) {\n                  next = parent.content[i + 1];\n\n                  if (next.is('declarationDelimiter')) {\n                    if (!parser.options.include) {\n                      result = helpers.addUnique(result, {\n                        'ruleId': parser.rule.name,\n                        'severity': parser.severity,\n                        'line': item.end.line,\n                        'column': item.end.column,\n                        'message': 'No trailing semicolons allowed'\n                      });\n                    }\n                  }\n                  else {\n                    if (parser.options.include) {\n                      result = helpers.addUnique(result, {\n                        'ruleId': parser.rule.name,\n                        'severity': parser.severity,\n                        'line': item.last('value').start.line,\n                        'column': item.last('value').start.column,\n                        'message': 'Trailing semicolons required'\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        });\n      });\n    }\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/final-newline.js":"'use strict';\n\nvar helpers = require('../helpers');\n\n/**\n * Get the 'last' node of the tree to test for an EOL\n *\n * @param {Object} node - The node whose last child we want to return\n * @returns {Object} The last node\n */\nvar getLastNode = function (node) {\n  var last = node.last();\n\n  return last ? getLastNode(last) : node;\n};\n\nmodule.exports = {\n  'name': 'final-newline',\n  'defaults': {\n    'include': true\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        last,\n        error = {\n          'ruleId': parser.rule.name,\n          'severity': parser.severity\n        };\n\n    // If the syntax is Sass we must recursively loop to determine the last node.\n    // This is not required for SCSS which will always use the last node in the\n    // content of the parent stylesheet node\n    if (ast.syntax === 'sass') {\n      last = getLastNode(ast);\n    }\n    else {\n      last = ast.content[ast.content.length - 1];\n    }\n\n    if (!last.is('space') && !last.is('declarationDelimiter')) {\n      if (parser.options.include) {\n        error.line = last.end.line;\n        error.column = last.end.column;\n        error.message = 'Files must end with a new line';\n        result = helpers.addUnique(result, error);\n      }\n    }\n    else if ((last.is('space') || last.is('declarationDelimiter'))) {\n      if (!helpers.hasEOL(last.content) && parser.options.include) {\n        error.line = last.start.line;\n        error.column = last.start.column;\n        error.message = 'Files must end with a new line';\n        result = helpers.addUnique(result, error);\n      }\n      else if (helpers.hasEOL(last.content) && !parser.options.include) {\n        error.line = last.start.line;\n        error.column = last.start.column;\n        error.message = 'Files must not end with a new line';\n        result = helpers.addUnique(result, error);\n      }\n    }\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/bem-depth.js":"'use strict';\n\nvar helpers = require('../helpers');\nvar selectorHelpers = require('../selector-helpers');\n\n/**\n * Get number of BEM elements in\n * @param   {string}  str String representing a class selector\n * @returns {integer}     Number of BEM elements in str\n */\nvar bemDepth = function (str) {\n  var elements = str.split('__').length;\n\n  if (elements >= 2) {\n    return elements - 1;\n  }\n\n  return 0;\n};\n\nmodule.exports = {\n  'name': 'bem-depth',\n  'defaults': {\n    'max-depth': 1\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByTypes(['ruleset', 'placeholder'], function (node) {\n      var name,\n          depth,\n          selectorAndExtensions,\n          maxDepth = parser.options['max-depth'];\n\n      if (node.is('placeholder')) {\n        name = selectorHelpers.constructSelector(node);\n        if (name) {\n          depth = bemDepth(name);\n          if (depth > maxDepth) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': node.start.line,\n              'column': node.start.column,\n              'message': ['Placeholder \\'%', name, '\\' should have ', maxDepth, ' or fewer BEM elements, but ',\n                depth, ' were found.'].join(''),\n              'severity': parser.severity\n            });\n          }\n        }\n      }\n      else {\n        selectorAndExtensions = helpers.collectSuffixExtensions(node, 'class');\n\n        selectorAndExtensions.forEach(function (selector) {\n          name = selector.content;\n          depth = bemDepth(name);\n\n          if (depth > maxDepth) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'line': selector.start.line,\n              'column': selector.start.column,\n              'message': ['Selector \\'.', name, '\\' should have ', maxDepth, ' or fewer BEM elements, but ',\n                depth, ' were found.'].join(''),\n              'severity': parser.severity\n            });\n          }\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/id-name-format.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'id-name-format',\n  'defaults': {\n    'allow-leading-underscore': true,\n    'convention': 'hyphenatedlowercase',\n    'convention-explanation': false,\n    'ignore': []\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('ruleset', function (ruleset) {\n      var selectorAndExtensions = helpers.collectSuffixExtensions(ruleset, 'id');\n\n      selectorAndExtensions.forEach(function (node) {\n        var name = node.content,\n            strippedName,\n            violationMessage = false;\n\n        if (parser.options.ignore.indexOf(name) !== -1) {\n          return;\n        }\n\n        strippedName = name;\n\n        if (parser.options['allow-leading-underscore'] && name[0] === '_') {\n          strippedName = name.slice(1);\n        }\n\n        switch (parser.options.convention) {\n        case 'hyphenatedlowercase':\n          if (!helpers.isHyphenatedLowercase(strippedName)) {\n            violationMessage = 'ID \\'#' + name + '\\' should be written in lowercase with hyphens';\n          }\n          break;\n        case 'camelcase':\n          if (!helpers.isCamelCase(strippedName)) {\n            violationMessage = 'ID \\'#' + name + '\\' should be written in camelCase';\n          }\n          break;\n        case 'pascalcase':\n          if (!helpers.isPascalCase(strippedName)) {\n            violationMessage = 'ID \\'#' + name + '\\' should be written in PascalCase';\n          }\n          break;\n        case 'snakecase':\n          if (!helpers.isSnakeCase(strippedName)) {\n            violationMessage = 'ID \\'#' + name + '\\' should be written in snake_case';\n          }\n          break;\n        default:\n          if (!(new RegExp(parser.options.convention).test(strippedName))) {\n            violationMessage = 'ID \\'#' + name + '\\' should match regular expression /' + parser.options.convention + '/';\n\n            // convention-message overrides violationMessage\n            if (parser.options['convention-explanation']) {\n              violationMessage = parser.options['convention-explanation'];\n            }\n          }\n        }\n\n        if (violationMessage) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': node.start.line,\n            'column': node.start.column,\n            'message': violationMessage,\n            'severity': parser.severity\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/max-file-line-count.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'max-file-line-count',\n  'defaults': {\n    length: 300\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    if (ast.end.line > parser.options.length) {\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': ast.end.line,\n        'column': 0,\n        'message': 'This file has ' + ast.end.line + ' lines, which exceeds the maximum of ' + parser.options.length + ' lines allowed.',\n        'severity': parser.severity\n      });\n    }\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/max-line-length.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'max-line-length',\n  'defaults': {\n    length: 80\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('space', function (space) {\n      var lineLength = 0;\n      if (helpers.hasEOL(space.content)) {\n        lineLength = space.start.column - 1;\n      }\n\n      if (lineLength > parser.options.length) {\n        result = helpers.addUnique(result, {\n          'ruleId': parser.rule.name,\n          'severity': parser.severity,\n          'line': space.start.line,\n          'column': 0,\n          'message': 'line ' + space.start.line + ' exceeds the maximum line length of ' + parser.options.length\n        });\n      }\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-attribute-selectors.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-attribute-selectors',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('attributeSelector', function (item) {\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': item.start.line,\n        'column': item.start.column,\n        'message': 'Attribute selectors are not allowed',\n        'severity': parser.severity\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-color-hex.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-color-hex',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('color', function (value) {\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': value.start.line,\n        'column': value.start.column,\n        'message': 'Hexadecimal colors should not be used',\n        'severity': parser.severity\n      });\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-combinators.js":"'use strict';\n\nvar helpers = require('../helpers');\n\n/**\n * Check if it's an exception (combinator or a parent selector before or after a space)\n *\n * @param {Object} node - The node to check\n * @param {Object} next - The next node\n * @param {Object} previous - The previous node\n * @returns {Boolean} True if exception\n */\nvar isException = function (node, next, previous) {\n  if (node.is('space')) {\n    if (next && next.is('combinator') || next.is('parentSelector')) {\n      return true;\n    }\n\n    if (previous && previous.is('combinator') || previous.is('parentSelector')) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = {\n  'name': 'no-combinators',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('selector', function (selector) {\n      selector.forEach(function (item, i) {\n        var previous = selector.content[i - 1] || false,\n            next = selector.content[i + 1] || false;\n\n        if (isException(item, next, previous)) {\n          return false;\n        }\n\n        if (item.is('combinator') || item.is('space')) {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': item.start.line,\n            'column': item.start.column,\n            'message': 'Combinators are not allowed',\n            'severity': parser.severity\n          });\n        }\n        return false;\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-disallowed-properties.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-disallowed-properties',\n  'defaults': {\n    'properties': []\n  },\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('property', function (node) {\n      var first = node.first();\n      if (!first.is('ident') || parser.options.properties.indexOf(first.content) === -1) {\n        return;\n      }\n      result = helpers.addUnique(result, {\n        'ruleId': parser.rule.name,\n        'line': node.start.line,\n        'column': node.start.column,\n        'message': 'Property `' + first.content + '` should not be used',\n        'severity': parser.severity\n      });\n    });\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-extends.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-extends',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('atkeyword', function (keyword) {\n      keyword.traverse(function (item) {\n        if (item.content === 'extend') {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': item.start.line,\n            'column': item.start.column,\n            'message': '@extend not allowed',\n            'severity': parser.severity\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/no-universal-selectors.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'no-universal-selectors',\n  'defaults': {},\n  'detect': function (ast, parser) {\n    var result = [];\n\n    ast.traverseByType('typeSelector', function (typeSelector) {\n      typeSelector.traverse(function (item) {\n        if (item.is('ident') && item.content === '*') {\n          result = helpers.addUnique(result, {\n            'ruleId': parser.rule.name,\n            'line': item.start.line,\n            'column': item.start.column,\n            'message': '* (universal) selectors are not allowed',\n            'severity': parser.severity\n          });\n        }\n      });\n    });\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sass-lint/node_modules/sass-lint/lib/rules/property-units.js":"'use strict';\n\nvar helpers = require('../helpers');\n\nmodule.exports = {\n  'name': 'property-units',\n  'defaults': {\n    'per-property': {},\n    'global': []\n  },\n  'detect': function (ast, parser) {\n    var result = [],\n        unitsAllowedGlobally = parser.options.global,\n        unitsAllowedPerProperty = parser.options['per-property'];\n\n    ast.traverseByType('declaration', function (declaration) {\n      var property = declaration.first('property'),\n          ident = property ? property.first('ident') : null,\n          propertyName = ident ? ident.content : null,\n          valueNode = declaration.first('value'),\n          hasDimension = valueNode ? !!valueNode.first('dimension') : null;\n      if (propertyName && hasDimension) {\n        // properties such as box-shadow may have multiple dimensions defined so enumerate through them\n        valueNode.forEach('dimension', function (dimension) {\n          var dimensionIdent = dimension ? dimension.first('ident') : null,\n              unitType = dimensionIdent ? dimensionIdent.content : null,\n              unitsAllowed = unitsAllowedPerProperty[propertyName];\n          // If a property is defined in unitsAllowed, then it will only validate those unit types\n          if (unitType && unitsAllowed) {\n            if (unitsAllowed.indexOf(unitType) === -1) {\n              result = helpers.addUnique(result, {\n                'ruleId': parser.rule.name,\n                'severity': parser.severity,\n                'line': dimension.start.line,\n                'column': dimension.start.column,\n                'message': 'Values for property \\'' + propertyName + '\\' may not use ' + unitType + ' units'\n              });\n            }\n          }\n          // If no units are defined in unitsAllowedGlobally, then allow all of them\n          // Otherwise, verify the given unit is in the unitsAllowedGlobally list.\n          else if (unitType && unitsAllowedGlobally.length && unitsAllowedGlobally.indexOf(unitType) === -1) {\n            result = helpers.addUnique(result, {\n              'ruleId': parser.rule.name,\n              'severity': parser.severity,\n              'line': dimension.start.line,\n              'column': dimension.start.column,\n              'message': 'Values for property \\'' + propertyName + '\\' may not use ' + unitType + ' units'\n            });\n          }\n        });\n      }\n    });\n    return result;\n  }\n};\n"}